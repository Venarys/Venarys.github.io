<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LIS LCS 以及相应DP模型的拓展 (一)</title>
      <link href="/2022/12/04/LCIS/"/>
      <url>/2022/12/04/LCIS/</url>
      
        <content type="html"><![CDATA[<h1 id="LIS-LCS-以及相应DP模型的拓展-一"><a href="#LIS-LCS-以及相应DP模型的拓展-一" class="headerlink" title="LIS LCS 以及相应DP模型的拓展 (一)"></a>LIS LCS 以及相应DP模型的拓展 (一)</h1><p>本来只是想写一篇题解，但总喜欢扯得太远，那干脆定一个大点的题把这些都包括进来吧。可能废话比较多，但有时间还是看看吧，说不定能有什么新思考<br>本文主要讲讲最长递增子序列（LIS），最长公共子序列（LCS）以及一些拓展dp问题。当然这些问题有的不止有dp解法。</p><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><blockquote><p>给定一个数列 $a_i$，求他们的最长严格递增子序列。<br><br>可见<a href="https://acm.hdu.edu.cn/showproblem.php?pid=1257">HDOJ-1257</a></p></blockquote><h3 id="LIS的求法"><a href="#LIS的求法" class="headerlink" title="LIS的求法"></a>LIS的求法</h3><p>当让我们也可以不求严格递增只求递增，递减也行，主要思想是一样的。<br>这里再给出两个概念</p><blockquote><p>子序列：把一个序列 $a_i$ 删除某些元素得到的序列 $b_j$,称 $b_j$ 为 $a_i$ 的子序列</p></blockquote><p>注意把子序列和子串的概念区分开，子串是连续的，子序列可以不连续。但他们的相对位置都没有发生变化，序列 $a_i$ 中 $m$ 在 $n$ 的后面，子序列和子串中还是 $m$ 在 $n$ 的后面。</p><blockquote><p>严格递增序列：一个序列 $a_n$，对于任意的 $1 \leq i &lt; j \leq n$，都有 $a_i &lt; a_j$</p></blockquote><p>通俗的讲就是一个序列，后面的数都要比前面的数大，注意严格是 $&lt;$ 不是 $\leq$的意思，$\leq$ 叫做递增，不叫严格递增。</p><h4 id="朴素"><a href="#朴素" class="headerlink" title="朴素"></a>朴素</h4><p>那这问题怎么做捏。<br>首先思考朴素做法，对于数列中的每一个数，暴力搜索以她为结尾（为开头也可以）的严格递增子序列长度，取最大值。时间复杂度为 $O(2^n)$ 蛮难绷住的。上个代码（注意这里展示的代码都是针对LIS，不是针对HDOJ-1257的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">//a数组存序列,ans存答案</span><br><span class="line">int n,a[1314520],ans;</span><br><span class="line">//计算以a[i]结尾的上升子序列的长度，并更新答案</span><br><span class="line">void dfs(int i,int len);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">//读入数组</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i = 1;i &lt;= n;++i) cin &gt;&gt; a[i];</span><br><span class="line">//枚举子序列的结尾a[i]</span><br><span class="line">for (int i = 1;i &lt;= n;++i) dfs(i,1);</span><br><span class="line">//输出答案</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void dfs(int i,int len)&#123;</span><br><span class="line">//枚举每条路</span><br><span class="line">for (int j = 1;j &lt; i;++j)</span><br><span class="line">//如果这条路合法，就搜她</span><br><span class="line">if (a[j] &lt; a[i]) dfs(j,len+1);</span><br><span class="line"></span><br><span class="line">//更新答案</span><br><span class="line">ans = max(ans,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是很慢的代码，随机数据测试发现，序列长度132个的就得跑6秒。当然是行不通的（TLE）</p><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><p>思考改进，我们可以发现dfs效率慢的原因就是重复搜索了很多状态，理论上我们可以用记忆化搜索来优化，记忆化搜索其实已经就是动态规划了。（以后有空我再展开说说这一块）但这个dfs不是单纯的返回某个值，而是不断更新全局最大值，所以不好实现记忆化搜索，我们直接尝试dp。</p><blockquote><p>能用dp三个必备要素：最优子结构，无后效性，子问题重叠</p></blockquote><blockquote><p><em>Future  never  has  to  do  with  past  time  ,but  present  does</em>.</p></blockquote><p>然而我们使用dp时还是凭经验行事比较多，甚至上面一些“必备要素”不满足的情况下我们还有处理方法（挖坑）。</p><p>我们考虑dp状态的时候一般有两条路可以走，一是从阶段，状态，决策去考虑，这种类似于递推思想，二是从集合的角度思考问题，一个状态看成一个集合，考虑他包含了什么子集，这种就类似于递归的思想。不过这只是思考方式，dp的代码实现其实都是可以递归和递推相互转化的。本质也可以从图论的角度思考（多扯一些）。</p><blockquote><p>动态规划对状态空间的遍历构成一张有向无环图，遍历顺序就是该有向无环图的一个拓扑序</p></blockquote><p>上面的东西有点深了，初学不理解没有关系，可以以后慢慢回味</p><p>我们尝试从集合的角度思考问题（我觉得这样比较直观）。</p><ol><li>首先考虑状态表示，这一步还是比较吃经验的（多刷题），在这种序列dp里面，我们状态表示都离不开序列的下标。再结合上面暴力搜素的代码，这题我们直接用 $f_i$ 表示以 $a_i$ 结尾的最长递增子序列的长度。</li><li>再思考状态计算，观察这个状态包含了什么子状态，即这个状态能有什么其他状态推过来。可以发现至少这个状态不会和 $i$ 之后的状态有关（也是无后效性），从集合划分考虑状态计算，$f_i$ 包含了不选上 $a_i$ 和选上 $a_i$ 两种子状态，不选上 $a_i$ 的状态就是 $i$ 之前的最长上升子序列的长度，表示出来就是 $\max\limits_{1 \leq j &lt; i} f_j$，而选上的状态就是再加个一，即 $\max\limits_{1 \leq j &lt; i} f_j + 1$。但还要注意的一点是，不是什么时候都可以选上的，要满足递增必须要满足 $a_j &lt; a_i$。两个状态取max，即最后我们推理出来的状态转移方程为<br>$$<br>f_i &#x3D; \begin{cases}\max\limits_{1 \leq j &lt; i} f_j + 1&amp;\text{$a_j &lt; a_j$},\\max\limits_{1 \leq j &lt; i} f_j&amp;\text{$a_j \not&lt; a_j$}\end{cases}<br>$$<br>把 $f_i$ 全都初始化 $1$ （即以当前 $a_i$ 结尾的数的LIS长度至少为 $1$）等价变形简化一下可得(至少他们在算法实现中是等价的)<br>$$<br>f_i &#x3D; \max\limits_{1 \leq j &lt; i,a_j &lt; a_i} (f_i ,f_j+1)<br>$$<br>然后就可以写程序了捏，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1314520;</span><br><span class="line">int a[N],f[N],n,ans;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i = 1;i &lt;= n;++i) cin &gt;&gt; a[i],f[i] = 1;</span><br><span class="line"></span><br><span class="line">//递推，开始dp</span><br><span class="line">for (int i = 1;i &lt;= n;++i)</span><br><span class="line">for (int j = 1;j &lt; i;++j)</span><br><span class="line">//如果a[j]能选，更新答案</span><br><span class="line">if (a[j] &lt; a[i])</span><br><span class="line">f[i] = max(f[i],f[j]+1);</span><br><span class="line"></span><br><span class="line">//注意最后答案不一定是以a[n]结尾，所以要遍历一遍取最大值</span><br><span class="line">for (int i = 1;i &lt;= n;++i) ans = max(ans,f[i]);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度为 $O(n^2)$ 已经比暴力快了很多了。不够我们还有更快的 $O(nlogn)$ 的方法</li></ol><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>此做法基于贪心，大致做法就是维护一个数组，并从前往后扫描数组。先讲讲这题最少拦截系统的题解可能更容易理解。</p><h3 id="HDOJ-1257题解"><a href="#HDOJ-1257题解" class="headerlink" title="HDOJ-1257题解"></a>HDOJ-1257题解</h3><blockquote><p>某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.</p></blockquote><blockquote><p>(8 是导弹总个数).<br><br> input: 8 389 207 155 300 299 170 158 65<br><br>输出拦截所有导弹最少要配备多少套这种导弹拦截系统.<br><br>output: 2</p></blockquote><p>怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.</p><p>简要意思就是导弹只能往下打或保持高度不变，所以求的就是至少要多少个不上升子序列能覆盖整个序列。其实球的就是原序列的LIS长度，证明来：</p><blockquote><p>我们如果求出了这些覆盖原序列的最长上升子序列，如样例里的{389,207,155}和{300,299,170,158,65}。那我们肯定能在后一个序列中找到一个数，和前一个数构成上升子序列，否则后一个序列应该接在前一个的后面。得证</p></blockquote><p>也不复杂，所以这题就是求LIS的裸题，可以用上面讲的方法求LIS。但从这题我们可以发现LIS的个数求的就是至少要多少个不上升子序列能覆盖整个序列。所以很自然想到贪心做法。维护一个数组 $d_n$ ，并从前往后扫描数组 $a_n$ 。如果当前数 $a_i$ 比数组 $d_n$ 末尾的数还要大，就把她作为数组末尾元素，数组长度加一。否则就在数组 $d_n$ 中查找第一个大于她的数 $d_k$ ，把  $d_k$ 换成 $a_i$ （即把这个导弹用目前最低位置的拦截系统拦截掉）。我们还可以用贪心的决策包容性去解释这种做法。最后数组长度就是原序列LIS的长度。容易发现数组始终是单调递增的，所以可以用二分优化。总的复杂度为 $O(nlogn)$的。上代码：(注意代码针对的是LIS，不是题目)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">//用一个MAXN宏更方便</span><br><span class="line">#define MAXN 1000010</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">//定义变量</span><br><span class="line">int n,a[MAXN],d[MAXN],len,x;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1;i &lt;= n;++i) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">//len初始为1，这里我们下标从1开始</span><br><span class="line">len = 1;</span><br><span class="line">    d[len] = a[1];</span><br><span class="line">    for (int i = 1;i &lt;= n;++i)&#123;</span><br><span class="line">        if (a[i] &gt; d[len])</span><br><span class="line">            d[++len] = a[i];</span><br><span class="line">        else&#123;</span><br><span class="line">//查找d里第一个不小于a[i]的数，将他替换</span><br><span class="line">//即把导弹接它后面</span><br><span class="line">            x = lower_bound(d + 1,d+len + 1,a[i]) - d;</span><br><span class="line">            d[x] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们基于贪心的 $O(nlogn)$ 做法。我们从题目出发想到了这种做法，属于是ACMer促进CS发展（）。</p><p>说回DP，我们可以基于LIS的dp思想：用 $f_i$ 表示当前状态，可以由  $i$ 前面的状态得到。我们来试试其他类型的问题</p><h2 id="最大上升子序列和"><a href="#最大上升子序列和" class="headerlink" title="最大上升子序列和"></a>最大上升子序列和</h2><blockquote><p>给定一个数列 $a_i$，求他们的最大的严格递增子序列的和<br><br>注意最大的上升子序列和不一定是LIS的和</p></blockquote><p>还是和LIS一样，我们用 $f_i$ 表示以 $a_i$ 结尾的最大上升子序列和。那状态计算呢，很简单，这里直接给出，可以思考一下:<br>$$<br>f_i &#x3D; \begin{cases}\max\limits_{1 \leq j &lt; i} f_j + a_i&amp;\text{$a_j &lt; a_j$},\\max\limits_{1 \leq j &lt; i} f_j&amp;\text{$a_j \not&lt; a_j$}\end{cases}<br>$$<br>即<br>$$<br>f_i &#x3D; \max\limits_{1 \leq j &lt; i,a_j &lt; a_i} (f_i ,f_j+a_i)<br>$$</p><p>所以只要把上面dp的代码改一个数字，问题就解决了，这里就不上代码了。</p><h2 id="登山"><a href="#登山" class="headerlink" title="登山"></a>登山</h2><blockquote><p>五一到了，PKU-ACM队组织大家去登山观光，队员们发现山上一个有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？<br>详见 <a href="http://noi.openjudge.cn/ch0206/1996/">noiOJ-1996</a></p></blockquote><p>当然我们可以用这种方法求最长上升子序列，当然也可以最长下降子序列（LDS）。我们可以改个符号判断，也可反着求一遍LIS。</p><p>而这题，我们就可以枚举每个点，求以这个点以这个点开始下山，即以这个点为顶点，能浏览的景点数，取个max即可。求景点数就只要求以这个点为结尾的LIS长度和以这个点为开头的最长下降子序列长度就行。如上所说，正反求两边LIS即可，上个代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1024;</span><br><span class="line">//f[i]存以a[i]结尾的LIS长度</span><br><span class="line">//g[i]存以a[i]开头的LDS长度，</span><br><span class="line">// 即倒过来的a[i]结尾的LIS长度</span><br><span class="line">int f[N],g[N],a[N],n,ans;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">//读入数列</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1;i &lt;= n;++i) cin &gt;&gt; a[i],f[i] = 1,g[i] = 1;;</span><br><span class="line">    </span><br><span class="line">//正着来一遍dp求LIS，求f[i]</span><br><span class="line">    for (int i = 1;i &lt;= n;++i) for (int j = 1;j &lt; i;++j)</span><br><span class="line">        if (a[j] &lt; a[i]) f[i] = max(f[i],f[j]+1);</span><br><span class="line">    //反着再来一把遍，求出g[i]</span><br><span class="line">for (int i = n;i &gt;= 1;--i) for (int j = n;j &gt; i;--j)</span><br><span class="line">        if (a[j] &lt; a[i]) g[i] = max(g[i],g[j]+1);</span><br><span class="line">    </span><br><span class="line">//最后枚举顶点，能浏览的景点数就为f[i]和g[i]的和</span><br><span class="line">//因为这么加起来还多加了个自己，所以减去1</span><br><span class="line">    for (int i = 1;i &lt;= n;++i) ans = max(ans,g[i]+f[i]-1);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这就是LIS的dp了，就讲到这里吧，我们接下来讲讲最长公共子序列LCS</p><p>来不及写了，先这样吧，下周回来再讲</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些思考</title>
      <link href="/2022/12/02/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/2022/12/02/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><div class="note info flat"><p>本故事包括人名纯属虚构 </p></div><p>感觉这样子比qq群更有感觉，而且这微软的打字效果做的也蛮不错的</p><blockquote><p>以上全是废话，以下也是。</p></blockquote><p>怎么说呢，我感觉之前的那个我回来了，或者说之前那个我走了。记得我一年之前，我也有开始随便写一下这种青春伤感文学，但后来读的书少了，其实是更多了，生活也过得“更好了”。上高中之前，我不知道会遇见谁，又会发生什么故事，至少初中的我活得挺废物的。</p><p>初中的时候，我就有种感觉，感觉我对于周围的环境有一种“金鳞岂是池中物”的中二感觉，那时候觉得我是比周围的人强一点才有这种感觉。后来上了高中，我甚至还有这种感觉。之后才慢慢知道，原来只是我不合群的原因。不会类比。刚上高中时我还有一股劲，感觉没几个能打的，至少在我周围吧。我甚至还买了数竞好多本书还有高考数学五三，最后还是没懂多少，没有什么深度。之后用甚么求导装b还被童国顺再班上骂，然后全班都知道我多少有点nb。可是我数学还是只考那么一点分。再加上后来学了信竞，知识面只能说是更广了，但还是不深。</p><p>这就有了一种现象，就是我对很多东西的麻木，钝感。看到别人什么用微积分开装只觉得他们幼稚，很多人看到我在看什么数论就在那喊，“这不是大学学的么”。我的感觉就是他们是在用考试，用学历拿去限制知识。其实搞竞赛都知道，宁德的教育资源对于福州厦门来说贞德p都不是。也不用说浙江四川那些强省了。我在洛谷上遇到很多初中生说什么这次省选考差了，只能去考CMO了，还有什么组合数学我不会，我只学了数学分析这种让人汗颜的发言。人与人之间的差距贞德蛮大的。很多人包括我数学老师都喜欢吹天才韦神。现在微软输入法都能有他。我也知道他很强，IMO金牌。可是就是去年的IOI金牌邓明杨，前几年也拿了IMO的金牌，然后直接润去MIT了，还有北大数学系之前很多大神，之前我们一些农村学校有新东方的老师来做宣传，然后给我们免费上一段时间的课。然后给我上课的老师就是北大的，我康康还能不能找到那篇报告，找不到了不要了。既然这一段讲了这么多这些事，那我就在讲一件最近的事吧。昨天NOIP比赛，考点师大附中。我看到了他们有校内自己的online judge，做的挺漂亮的像github那种风格，还能动态显示校内排名（有上百人），还有学校暑期特训，冬令营什么的。我就觉得差距真的很大。</p><p>有点困，快点把想说的说完吧</p><p>其实我事在考完NOIP之后在回家路上有了一点思考，不是上面这一些，这些其实是在我脑海里蛮久的东西，就是资源不均等。甚至这次语文考试我也是这么写的。但我有点不甘心，所以之前我拼命卷竞赛，想赢回一点面子，毕竟宁德一中要对这些事情重视，就必须有人做出成绩。而且这次NOIP，其实信竞流程事这样的。先是CSP-J\S两轮认证，然后第二轮认证的优胜者参加NOIP竞赛。可是我们9月份比了第一轮（笔试），然后10月份第二轮（机试）因为福州疫情取消了，所以我们NOIP的名额只能由第一轮成绩决定，而且分到整个宁德的名额只有8个，然后再分给宁德各个一中，最后宁德一中就拿到了三个，最后老师靠关系又推荐了一个，只上了四个。可是我们队里（不只是一中）目前是高一3个，高二3个，高三1个。然后我们就按照第一轮成绩切，本来40分过线现在只能切走前四名。高一的一个就差了0.5分。然后高一就都没上，这放其他学校是没有的。然后到福州就可以看到，师大附中他们有十几个人，厦门双十也有十几个人，福州三中，厦门一中，厦大附中…</p><p>这次我也是练了蛮久的了，其实是奔着省一去的，然后想着如果能润个省队那可太有面了。可是就成了现在这样了，第一题我以为拿下了，被阴了，然后看到第三题，公式都退出来了，如果拿下两题省一一般就有了，可是就是紧张还是什么，卡了蛮久的，之前背过的模板就是打不出来，这一题还是没拿下，剩下两题甚至还没来得及骗分，（甚至文件都没建），然后就寄了，以为完整拿下一题运气不好也有省三，没想到寄大了。确实是对不起高一学弟了。</p><p>然后就是回家的路上了。高速旁都是绿油油的山，还有黑漆漆的隧道。我就在想以后怎么走，信竞和其他竞赛不太一样，高二是最后的机会，高三可以参赛，但不能进省队（我也是高二之后才知道，不然高一就不拜了），所以意义就不大了，很多人高二就是最后一次了，而我是第一次。浙江应该是信息学奥赛最逆天的一个省，大学生的ACM竞赛浙大队伍只能排在全省第八，前七都是中学。而他们这些人大多都是小学开始入门（甚至更逆天）。可是我只能上了一中之后才知道有竞赛这个东西，之前会一点编程但都是瞎玩。</p><p>又扯歪了。我上面说了很多，都是偏黑暗的。现在来讲讲我在车上的思考吧。</p><p>我在想，我之前想要的到底是什么，挺民哲的。我觉得我就是执念太重，真正机会到我手上的时候我却如叶公好龙一般把握不住。像我之前的考试状态一样，每次都渴望超常发挥译名惊人。可是实力确实在那里，执念太重反而施展不出来。失败总是贯穿人生始终，这就是人生。之前的我（高一后期道高二这一阶段吧）自作主张的给自己赋予了一种使命。或许这就是竞赛的优点吧，也是缺点。然后我就有一种感觉，有时感觉很紧张，感觉干什么事都是浪费时间，有时又很迷茫，面对一个问题时，又会被其他相关不大的问题带着走。就想我暑假的时候，确实是想卷个两周。也是贞德没怎么玩游戏。可是为了所谓更优雅的写代码，我真的重装系统重装了两周。还有我之前嫌国内计算机书籍翻译的不好（其实大多数都挺好的）,而且我正好有电子书，正好zlib还没被封，我甚至去硬刚英语原本，当然也就是几个小时看几页就刚不动了（甚至想去学日语）。这就是执念。</p><p>所以我就在构思一种新的生活方式。或许我压根就没有什么使命，我也不用去为了什么。尽管享受过程也是一种快乐。我说的不是放纵。而是积极的，向前的，慢慢的提高自己。厚积，再厚积，再鸡，享受鸡的过程。有需要的时候再薄发吧。就是这种感觉。其实好久没体验过这种感觉了。我感觉我这一年可以分成两个阶段，从刚开始的雄心壮志，快乐且幼稚。到后来的背着蛮重的东西向前走着，坚定而又迷茫。最后是现在的我。我感觉我又回去了，不过褪去了些许幼稚，多了，我也说不清多了什么，我不用再去想什么公平啊使命啊之类泛泛的东西。我不是说躺平。而是“但是没有目标，走到哪就算哪真的很快乐，这就是陕北的乐趣吧”这意思。这也对应了我开头的话“我感觉之前的那个我回来了，或者说之前那个我走了”，走的是把一大堆东西硬扛在肩上的我，回来的是快乐的一个我，至于她，也不用有太多执念，她等我的话，我也等她。就够了。</p><p>讲完了，睡觉吧</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瞎写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2022/12/01/test/"/>
      <url>/2022/12/01/test/</url>
      
        <content type="html"><![CDATA[<h1 id="芜湖"><a href="#芜湖" class="headerlink" title="芜湖"></a>芜湖</h1><p>Hello,World !!!</p><ul><li>列表康康</li><li>sdasjdkas</li><li>sajdkljas</li></ul><ol><li>sajdhasuhd</li><li>shajdhas</li><li>shdjhasdh</li><li>nashdjh</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> First step </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算 补码 反码</title>
      <link href="/2022/10/05/%E4%BD%8D%E8%BF%90%E7%AE%97-%E8%A1%A5%E7%A0%81-%E5%8F%8D%E7%A0%81/"/>
      <url>/2022/10/05/%E4%BD%8D%E8%BF%90%E7%AE%97-%E8%A1%A5%E7%A0%81-%E5%8F%8D%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算-补码-反码"><a href="#位运算-补码-反码" class="headerlink" title="位运算 补码 反码"></a>位运算 补码 反码</h1><p>很多初学者经常搞不懂<strong>补码反码原码</strong>这些东西，今天我就在这里好好理一下。</p><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>先来讲讲基本的与或等运算，会的可以直接跳过</p><table><thead><tr><th align="center"></th><th align="center">与 AND</th><th align="center">或 OR</th><th align="center">异或 XOR</th><th align="center">非 NOT</th></tr></thead><tbody><tr><td align="center">1,1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center"></td></tr><tr><td align="center">1,0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">0,0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"></td></tr><tr><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1</td></tr><tr><td align="center"></td><td align="center">有0则为0</td><td align="center">有1则为1</td><td align="center">异常的或，在都为1的时候为0</td><td align="center">取反</td></tr></tbody></table><p>容易看出，<strong>与，或，异或</strong>是二元运算（即有两个操作数，如加减乘除也是二元运算），且满足交换律。而非是一元运算。当然也可以有多位一起参加运算，如10 ^ 11 &#x3D; 01，各位运算是独立的  </p><p>另外，与，或，异或也满足结合律：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a &amp; b) &amp; c == a &amp; (b &amp; c)</span><br><span class="line">(a | b) | c == a | (a | c)</span><br><span class="line">(a ^ b) ^ c == a ^ (b ^ c) </span><br></pre></td></tr></table></figure><p>其中&amp; ，|，^ 在C语言中分别表示与，或，异或运算，现在来证明一下：</p><p>与：只要位上有1，结果必是1<br>或：只要位上有0，结果必是0<br>异或：位上1的个数为奇数，结果就是1,反之为0</p><hr><h2 id="原码，反码"><a href="#原码，反码" class="headerlink" title="原码，反码"></a>原码，反码</h2><p>现在来讲讲正题。首先我们要知道<strong>补码和反码是两种储存数据的方式</strong></p><p>大家都知道计算机里存储的是二进制数，如果我们用八个位表示一个整数，<br>如<strong>2 &#x3D; (00000010)<strong>，其中00000010就叫做2的</strong>原码</strong>。</p><p>这样我们就可以用八位表示0～255的任意整数了。但是我们如何表示负数呢。我们就想出了反码这种东西。要理解这个还得了解一下计算机如何执行加法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2+1 = (00000010) + (00000001) = (00000011) = 3</span><br><span class="line">2+2 = (00000010) + (00000010) = (00000100) = 4</span><br><span class="line">2+3 = (00000010) + (00000011) = (00000101) = 5</span><br></pre></td></tr></table></figure><p>可以看出就是两个加数各位异或，再加个与运算判断是否进位。（可以用这个原理在MC用红石搭个简单的加法器）。</p><p><strong>所以我们如果要表示负数</strong>（最关键的问题），可以用 a + (-a) &#x3D; 0来定义表示方法。我们不妨定义(11111111)为-0（也就是0）这样我们我们就可以把一个数各位取反来表示她的相反数。如(~表示取反)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2 = (0000 0010)</span><br><span class="line">~2 = (1111 1101) = -2 //这些操作在实际机子上不成立，因为我们现在是以补码方式存储数据</span><br><span class="line">2 + -2 = (1111 1111) = 0</span><br><span class="line">---</span><br><span class="line">0 = (0000 0000)</span><br><span class="line">~0 = (1111 1111) = -2</span><br><span class="line">0 + -0 = (1111 1111) = 0</span><br><span class="line">---</span><br><span class="line">127 = (0111 1111)</span><br><span class="line">~127 = (1000 0000) = -127</span><br><span class="line">127 + -127 = 0</span><br></pre></td></tr></table></figure><p>这就是<strong>反码</strong>,指的不仅是按位取反，还指这种存储数据的方式</p><p>由此可见，(1000 0000)不能再像原来那样表示128了，因为他现在表示-127，以及128以上数（最高位为1）的表示方法同样被抢走了，所以我们就不表示这些数，那现在我们用八位表示的整数范围便变成了[-127,127]</p><p>我们还可以知道，最高位是0的数现在都是正数，而正数取反后得到负数，所以负数的最高位是1（不严谨的讨论，-0看作负数，0看作正数^_^）所以我们现在把最高位叫做<strong>符号位</strong></p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>可是我们知道我们现在都是以补码方式存储数据，补码又是什么，相对于反码又有什么优势呢</p><p>补码也叫做<strong>二补数</strong>，而刚刚介绍的反码叫做<strong>一补数</strong>，这也可以看出补码是比反码先进一点。</p><p>仔细看看我们刚刚的反码，我们用了(0000 0000)和(1111 1111)两种方式表示0，这使0的编码不唯一了，很多情况下我们需要特殊判断，导致效率低下（特别是电路设计中）。所以我们用补码解决了这个问题。</p><p>补码和反码的区别就在于负数的表示。回到最初的问题，我们需要表示负数，但现在我们不能再用(1111 1111)表示0了，要坚持一个0原则(0000 0000)，可我们的 a + (-a) &#x3D; 0还是要成立的，所以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 = (0000 0010)</span><br><span class="line">2 + -2 = 0 = (0000 0000)</span><br><span class="line">-2 = (1111 1110)</span><br></pre></td></tr></table></figure><p>我们就有了另一种数据存储方式，(1111 1110)就是-2的补码。现在我们来研究一下她的性质</p><p>我们容易得到：（1溢出到最高位之外了，我们不要了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1111 1111) + (0000 0001) = (0000 0000)</span><br><span class="line">(0000 0001) = 1</span><br></pre></td></tr></table></figure><p>可得(1111 1111)表示-1</p><p>还有：（再说一次～表示取反）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2 = (0000 0010)</span><br><span class="line">～2 = （1111 1101）</span><br><span class="line">2 + ～2 = (1111 1111) = -1</span><br><span class="line">2 + ～2 + 1 = 0</span><br><span class="line">---</span><br><span class="line">a + ~a = (1111 1111) = -1</span><br><span class="line">a + ~a + 1 = 0</span><br></pre></td></tr></table></figure><p><strong>所以我们得到(~a+1)就是a的补码</strong>，也就是我们常说的补码等于反码加一</p><p>这样子我们就解决了0的唯一性，现在我们有：（可以去和上面的反码方式对比一下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 = (0000 0000)</span><br><span class="line">-0 = ~0 + 1 = (1111 1111) + 1 = (0000 0000)</span><br><span class="line">---</span><br><span class="line">127 = (0111 1111)</span><br><span class="line">-127 = ~127 + 1 = (1000 0000) + 1 = (1000 0001)</span><br></pre></td></tr></table></figure><p>那我们现在就可以比反码多表示一位了，可以看出(1000 0000)这一种表示方法没有被抢走，所以我们就可以用(1000 0000)表示-128。所以我们能表示的整数范围现在就是[-128,127]。</p><p>这就是补码和反码两种存储数据方式。</p><hr><p>我们可以用程序实验一下计算机里是如何用补码存储数据的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>;a &lt;= <span class="number">10</span>;++a)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,a,~a,~a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0 -1 0</span><br><span class="line">1 -2 -1</span><br><span class="line">2 -3 -2</span><br><span class="line">3 -4 -3</span><br><span class="line">4 -5 -4</span><br><span class="line">5 -6 -5</span><br><span class="line">6 -7 -6</span><br><span class="line">7 -8 -7</span><br><span class="line">8 -9 -8</span><br><span class="line">9 -10 -9</span><br><span class="line">10 -11 -10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Ubuntu简单软件管理命令</title>
      <link href="/2022/06/05/linux-ubuntu%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/06/05/linux-ubuntu%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu-简单软件管理命令"><a href="#ubuntu-简单软件管理命令" class="headerlink" title="ubuntu 简单软件管理命令"></a>ubuntu 简单软件管理命令</h1><p>查看已安装软件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l </span><br></pre></td></tr></table></figure><p>关键词(“***”)查找软件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l|grep &quot;***&quot;</span><br></pre></td></tr></table></figure><p>卸载软件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt --purge remove &quot;***&quot;  </span><br><span class="line">#这里的&quot;***&quot;是要在dpkg里的名字，可以通过关键字查找得到</span><br></pre></td></tr></table></figure><p>安装软件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i &quot;***.deb&quot;</span><br></pre></td></tr></table></figure><p>压缩文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zip (-r) filename dirname</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把<span class="built_in">dirname</span>压缩为filename.zip</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-r递归，压缩子目录，一般都要加</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同windows系统兼容好</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rar a filename.rar dirname</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把<span class="built_in">dirname</span>压缩为filename.rar</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">自动递归</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果提示未找到命令，执行</span></span><br><span class="line">sudo apt install rar</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf filename.tar dirname</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把<span class="built_in">dirname</span>压缩为filename.tar , 注意tar不能省</span></span><br><span class="line">tar -zcvf filename.tar.gz dirname</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把<span class="built_in">dirname</span>压缩为filename.tar.gz , tar.gz不能省,（只是参数多了个-z）</span></span><br><span class="line">tar -jcvf filename.tar.bz2 dirname</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压成tar.bz2,参数为-j,其他同上</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-v --verbose为显示过程</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-f --file 不知道能干吗，反正我试过了不能不加</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">linux中最常用 快用快用</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip filename</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把filename压缩为filename.gzip,只能鸭文件不能鸭目录（或许可以，但我不会）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以用tar打包后压缩，也可以直接用tar的-z参数做到，bzip2同</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所以不常用，可以用tar替代</span></span><br></pre></td></tr></table></figure><p>解压文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip filename.zip</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar x filename.rar</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf filename.tar</span><br><span class="line">tar -zxvf fliename.tar.gz</span><br><span class="line">tar -jxvf filename.tar.bz2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把压缩的-c换成-x</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gunzip filename.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不常用，可用tar替代</span></span><br></pre></td></tr></table></figure><p>先写这么多了，要去上学了。还有些压缩命令如gzip2等没写道，但这可以用tar的-j参数实现，记住这些一般就够用了，还有dpkg apt的细节我还不会，毕竟</p><blockquote><p>来路方长</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux使用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法大纲</title>
      <link href="/2022/05/29/%E7%AE%97%E6%B3%95%E5%A4%A7%E7%BA%B2/"/>
      <url>/2022/05/29/%E7%AE%97%E6%B3%95%E5%A4%A7%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="算法大纲"><a href="#算法大纲" class="headerlink" title="算法大纲"></a>算法大纲</h1><h2 id="for-oier"><a href="#for-oier" class="headerlink" title="for oier"></a><em>for oier</em></h2><p><img src="/2022/05/29/%E7%AE%97%E6%B3%95%E5%A4%A7%E7%BA%B2/img.png" alt="算法与数据结构"><p></p><p>简单聊一聊算法学习。<p></p><p>整个的学习主要分成算法与数据结构两大块。我相信很多人也听过<strong>程序 &#x3D; 算法+数据结构</strong>这句话，那我们就来分别讲讲这两个东西。<p></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这里我就不像教科书里那样赘述算法的定义性质什么的了。就直截了当的开始讲讲各个算法的特点，以及竞赛解题的思路<p></p><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>这或许不太能算的上一种算法，但这确实对于解题至关重要。对于一题算法题要是连暴力解法都想不出来，那这题也差不多拿不到了（裸题除外）。而其他算法（以及数据结构）也只是对代码进行重构优化<br><br><strong>其他算法决定你能拿几分，暴力决定你能不能拿分</strong><br><br>而这种算法之取决于你的思路，一些题目对智力要求不低，说他是最简单而又最难的算法不无道理。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>BFS，DFS，A<em>，IDDFS，IDA</em>等等等等，是一条蛮重要的路线，而且和图论密切相关，是必须掌握的。</p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>和暴力差不多，是人类最朴素的思想的产物。是一种重要的算法思想，很多题目或多或少都有他的身影，注意他是一种思想，而不想搜索一样是一种明确的算法。</p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>和贪心一样，也是一种重要的算法思想，log级别的优化经常用到</p><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p><strong>动态规划</strong>，简直太简直了（）<br><br>难题必备，具体思想我现在也没搞懂。</p><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>慢慢学吧</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>不会很难(吧)</p><h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><p>不会，以后再说。<p></p><p>既然是大纲，就简单写一写了，我也没有时间和实力展开写，<strong>以后再说</strong>吧</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>也是很重要的一块，特别是高级数据结构，题目难度不亚于DP。<p></p><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><p>大部分已经用STL实现，<strong>NOIP &#x3D; C语言+STL</strong>，STL要熟练掌握<br><br>数据结构和算法也密不可分，比如BFS就要借用队列来实现。</p><h3 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h3><p>树，树，树还是树。幸好的是STL的map已经实现了红黑树，这些奇怪的数也不用太纠结了，但线段树和树状数组这些东西，优化代码（题目数据很大）的时候还是需要的。<p></p><p>就先写这么多吧。<p></p><p>PS:最后提几句，oier真的挺不容易的，五大学科竞赛就信息学和高中学习相关最小。两头都得顾。别人铸剑三年，锋芒一朝。而我们要铸两把剑。特别是我这种小城市的学生，竞赛资源小，也不知道能走多远。只是不想放弃而已。等着吧，说不定就成了呢。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无题</title>
      <link href="/2022/05/29/untitled/"/>
      <url>/2022/05/29/untitled/</url>
      
        <content type="html"><![CDATA[<h1 id="随便写写"><a href="#随便写写" class="headerlink" title="随便写写"></a>随便写写</h1><p><em>2022 5 29 1:17</em><br><br>忙了一个晚上，什么也没干成，至少开始动笔了，就写写吧。<p></p><p>语法我也忘了差不多了，今晚我什么都不想讲了，就还是测试一下，把环境配好去学校不至于太尴尬。<br><br>测试数学$\alpha$<p></p><p>$\frac {a}{b}$<p></p><p>看看插件,感觉也没什么是必要的。这部机子的配置，一切还是轻装上阵为妙。<p>困了今天先到这里，哦不是早上先到这里，我看看能不能发博客。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八数码问题</title>
      <link href="/2022/04/03/Eight/"/>
      <url>/2022/04/03/Eight/</url>
      
        <content type="html"><![CDATA[<h1 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h1><p><strong>题目地址</strong>:</p><p><a href="https://www.acwing.com/problem/content/181/">Acwing</a></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1043">HDU</a></p><blockquote><p>在一个 3×3 的网格中，1∼8 这 8 个数字和一个 <code>X</code> 恰好不重不漏地分布在这 3×3 的网格中<br>在游戏过程中，可以把 <code>X</code> 与其上、下、左、右四个方向之一的数字交换（如果存在）。<br>我们的目的是通过交换，使得网格变为正确排列<br></p><p>把 <code>X</code> 与上下左右方向数字交换的行动记录为 <code>u</code>、<code>d</code>、<code>l</code>、<code>r</code>。<br>现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列</p></blockquote><p>我花了好几个晚上才完整的写了出来，毕竟还是新手，但独立写出来之后还有一点成就感(当然有参考)。下面就来小小提提我的思路吧。</p><blockquote><p>bfs不仅可以搜索路径，还可以搜索状态。</p></blockquote><p>这是我从黑书上看到的一句话，从后几个晚上便开始了我的不归路。</p><p>所以我也用黑书上的思路，__bfs+cantor__解决这道题</p><p>这题要寻找最短路径，所以bfs更适合</p><h2 id="1-广度优先搜索-BFS"><a href="#1-广度优先搜索-BFS" class="headerlink" title="1. 广度优先搜索 (BFS)"></a>1. 广度优先搜索 (BFS)</h2><p>这个思路很好理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始状态入队</span><br><span class="line">while(队列不为空)</span><br><span class="line">取出队首</span><br><span class="line">if(找到目标)</span><br><span class="line">返回答案</span><br><span class="line">else</span><br><span class="line">相邻状态入队</span><br></pre></td></tr></table></figure><p>伪代码非常清晰，现在我们把__文字展开成代码实现__得到。</p><p>首先我们联系一下问题</p><blockquote><p>输入占一行，将 3×3 的初始网格描绘出来。</p><p>例如，如果初始网格如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">x 4 6 </span><br><span class="line">7 5 8 </span><br></pre></td></tr></table></figure><p>则输入为：<code>1 2 3 x 4 6 7 5 8</code></p><p>输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。<br>如果答案不唯一，输出任意一种合法方案即可。<br>如果不存在解决方案，则输出 <code>unsolvable</code>。</p></blockquote><p>我们可以用多种方式存储状态，我这里选择的一维数组。<br>因为输出行动记录，我的思路就是用一个__结构体__存储__数组__和__上次到这次的行动__，还有__上次状态的地址__。</p><p>语言描述有点难懂，现在来看看代码实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">state</span>&#123;</span><br><span class="line"><span class="type">int</span> num[<span class="number">9</span>];<span class="comment">//数组</span></span><br><span class="line"><span class="type">char</span> ch;<span class="comment">//上次到这次的行动</span></span><br><span class="line"><span class="type">int</span> re;<span class="comment">//上次状态的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里说到说到上次状态的地址，这是一个__整数__而__不是一个指针__。<br>这是因为我们使用__数组__模拟bfs中的__队列__，这个__整数__是__数组下标__,<br>搜索的元素出队后，__不会删除__，而是数组头指针和尾指针的移动。所以我们可以这样记录地址</p><p>更详细的可以学习下队列相关知识。</p><p>实现一下，看不懂没关系，稍后会解释(看起来代码很长，其实很多重复的地方，读者可以试着优化)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">state <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//初始状态入队，把初始状态的上状态地址设为-1，以便区别与普通状态</span></span></span><br><span class="line"><span class="function">begin.re </span>= <span class="number">-1</span>;</span><br><span class="line">q[++tt] = begin;</span><br><span class="line"><span class="keyword">while</span>(tt &gt;= hh)&#123;</span><br><span class="line"><span class="comment">//是否找到，如果队首的九个数都和目标相同，则为找到。也可用memcmp等函数</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)</span><br><span class="line"><span class="keyword">if</span>(q[hh].num[i] == aim[i])</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">9</span>) <span class="keyword">return</span> q[hh];</span><br><span class="line">        <span class="comment">//寻找0的位置，我们在输入的时候把x换成0，这样子,方便数组存储</span></span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line"><span class="keyword">for</span>(z = <span class="number">0</span>;z &lt; <span class="number">9</span>;++z)</span><br><span class="line"><span class="keyword">if</span>(q[hh].num[z] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//判断相邻状态</span></span><br><span class="line"><span class="keyword">if</span>((z+<span class="number">1</span>)%<span class="number">3</span>)&#123;<span class="comment">//是否能向左，依题意得2 5 8这三个位置不能向左 </span></span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z+<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//是否查找过状态，vis定义为  如果找过则返回false，反则true</span></span><br><span class="line">            <span class="comment">//具体代码实现就不给了，因为后面后用一个更nb的函数代替</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">vis</span>(tmp.num))</span><br><span class="line">                q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z % <span class="number">3</span>)&#123;<span class="comment">//同上</span></span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">vis</span>(tmp.num)) q[++tt] = tmp;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z &gt; <span class="number">2</span>)&#123;<span class="comment">//ts</span></span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z<span class="number">-3</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">vis</span>(tmp.num)) q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z &lt; <span class="number">6</span>)&#123;<span class="comment">//t</span></span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z+<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">vis</span>(tmp.num)) q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">++hh;<span class="comment">//弹出队首，因为我们前面不是取出队首，而是直接用队首，所以在此弹出队首</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> begin;<span class="comment">//如果没有找到，返回begin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>: 因为我们用一维数组存储当前格子的状态，也就是（已经把x换成0）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 0</span><br></pre></td></tr></table></figure><p>存为 <code> 1 2 3 4 5 6 7 8 0</code> 对应的a[0] &#x3D; 1,a[1] &#x3D; 2,a[3] &#x3D; 2也就是3对应的__位置数组下标__为2   </p><p>由此可知，当0的__位置数组下标__为2，5，8是，不能往左走<br>同理  0，1，2时,不能往上0，3，6不右6，7，8不下<br>随后用if条件判断即可。</p><p>而行走我们用了swap函数，交换0(即x)的位置数组下标和目标位置的下标，完成一次行走</p><p>最后把__上次到这次的行动__和__上次位置地址__存储到tmp上，如果符合条件就入队。</p><h2 id="康托展开-Cantor-Expansion"><a href="#康托展开-Cantor-Expansion" class="headerlink" title="康托展开 (Cantor Expansion)"></a>康托展开 (Cantor Expansion)</h2><p>代码主体部分已经基本完成，但还有很多问题，比如判重函数 <em>vis()</em>  还没有实现，如果没有判重，程序会产生很多无效操作，复杂度大大增加，但如果使用暴力的方法判重，每次把新状态和9! &#x3D; 362880 个状态对比，可能有9!*9!次检查，必__TLE__</p><p>所以我们用到了这种数学方法__”康托展开”__判重</p><blockquote><p>康托展开是一种特殊的哈希函数</p></blockquote><p>实际上，康托展开听起来很高大上，其实就是__把几个数的排列映射到值上__，每个值对应一种排列，如4个数的全排列可以用4! &#x3D; 24个值表示，见下表</p><table><thead><tr><th>状态</th><th>Cantor</th></tr></thead><tbody><tr><td>0123</td><td>0</td></tr><tr><td>0132</td><td>1</td></tr><tr><td>0213</td><td>2</td></tr><tr><td>0231</td><td>3</td></tr><tr><td>……</td><td>……</td></tr><tr><td>3210</td><td>23</td></tr></tbody></table><p>那如何完成从状态到值的转换呢，当然是有公式滴<br>$$<br>X &#x3D; a_n(n-1)! + a_{n-1}(n-2)!+…+a_2\times1! + a_1 \times 0!<br>$$<br>其中，$a_i$表示原数的第i位在当前为出现的原数中排第几个(从0开始数的)<br>__乱七八糟__，对吧</p><p>其实这东西真不难，看着唬人而已，我们来展开几个数试试。</p><p><strong>0231</strong><br>第4位为0，0排第<strong>0</strong>个，0个数中<strong>没有数</strong>出现过，$a_4$ &#x3D; 0 - 0 &#x3D; 0;<br>第3位为2，2排第<strong>2</strong>个，2个数中<strong>1</strong>个0出现过，$a_3$ &#x3D; 2 - 1 &#x3D; 2<br>第2位为3，3排第<strong>3</strong>个，3个数中<strong>2</strong>个数(0,2)出现过，$a_2$ &#x3D; 3 - 2 &#x3D; 1<br>第1位为1，1排第<strong>1</strong>个，1个数中<strong>1</strong>个0出现过，$a_1$ &#x3D; 1 - 1 &#x3D; 0<br>所以<br>$X &#x3D; 0\times3! + 1\times2! + 1\times1! + 0\times0! &#x3D; 3$</p><p><strong>1032</strong> <br>第4位为1，1排第<strong>1</strong>个，1个数中<strong>没有数</strong>出现过，$a_4$ &#x3D; 1 - 0 &#x3D; 1;<br>第3位为0，0排第<strong>0</strong>个，0个数中<strong>没有数</strong>出现过，$a_3$ &#x3D; 0 - 0 &#x3D; 0<br>第2位为3，3排第<strong>3</strong>个，3个数中<strong>2</strong>个数(0,1)出现过，$a_2$ &#x3D; 3 - 2 &#x3D; 1<br>第3位为2，2排第<strong>2</strong>个，2个数中<strong>2</strong>个数(0,1)出现过，$a_1$ &#x3D; 2 - 2 &#x3D; 0<br>所以<br>$X &#x3D; 1\times3! + 0\times2! + 1\times1! + 0\times0! &#x3D; 7$</p><p>作了这些练习，有没有一种编程的欲望？下面给出代码实现(我自己写的，当然还有优化空间)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> org[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;<span class="comment">//原数</span></span><br><span class="line"><span class="type">int</span> factory[<span class="number">11</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;<span class="comment">//阶乘打表</span></span><br><span class="line"><span class="comment">//bool basket[10]之前定义在外面,debug找了好久才出错,数组很容易犯这种错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看有几个数出现过</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> * basket)</span></span>&#123;<span class="comment">//因为basket为cantor()的成员变量,所以传进来</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; x;++i)</span><br><span class="line"><span class="keyword">if</span>(basket[i])</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cantor</span><span class="params">(<span class="type">int</span> * a)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> basket[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//查看有什么数出现过,记得定义为成员变量,并初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)&#123;</span><br><span class="line">x += (a[i] - <span class="built_in">g</span>(a[i],basket)) * factory[<span class="number">8</span>-i];</span><br><span class="line">basket[a[i]] = <span class="literal">true</span>;<span class="comment">//找过的置1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是康托展开，我上面的解释是以编程，即应用的角度出发去理解的。读者也可以思考一下他的数学内涵(可从排列的角度出发)</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>我们的基本思路就是BFS+Cantor解决这玩意，当然还有双向bfs和A*等算法，读者可以尝试，下面给出我的AC代码(优化的可以)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">state</span>&#123;</span><br><span class="line"><span class="type">int</span> num[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> re;</span><br><span class="line">&#125;;<span class="comment">//定义状态结构体</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">char</span>&gt; ans;<span class="comment">//用vector存答案</span></span><br><span class="line">state q[<span class="number">666666</span>];<span class="comment">//模拟队列</span></span><br><span class="line"><span class="type">int</span> hh,tt = <span class="number">-1</span>;<span class="comment">//头,尾指针</span></span><br><span class="line"><span class="type">int</span> beg[<span class="number">9</span>];<span class="comment">//开始数组</span></span><br><span class="line"><span class="type">int</span> aim[<span class="number">9</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>&#125;;<span class="comment">//目标数组</span></span><br><span class="line"><span class="type">int</span> org[<span class="number">9</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;<span class="comment">//原数组，Cantor展开用</span></span><br><span class="line"><span class="type">int</span> factory[<span class="number">11</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;<span class="comment">//阶乘打表</span></span><br><span class="line"><span class="type">bool</span> vis[<span class="number">362881</span>];<span class="comment">//找过的数放进来</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> * basket)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; x;++i)</span><br><span class="line"><span class="keyword">if</span>(basket[i])</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cantor</span><span class="params">(<span class="type">int</span> * a)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> basket[<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)&#123;</span><br><span class="line">x += (a[i] - <span class="built_in">g</span>(a[i],basket)) * factory[<span class="number">8</span>-i];</span><br><span class="line">basket[a[i]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vis[x])<span class="comment">//判断是否找过</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//找过就false</span></span><br><span class="line">vis[x] = <span class="literal">true</span>;<span class="comment">//没找过就放进来</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//没找过就true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">state <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">state begin;</span><br><span class="line"><span class="built_in">memcpy</span>(begin.num,beg,<span class="keyword">sizeof</span> beg);<span class="comment">//把begin数组给初始状态</span></span><br><span class="line">begin.re = <span class="number">-1</span>;</span><br><span class="line">q[++tt] = begin;</span><br><span class="line"><span class="keyword">while</span>(tt &gt;= hh)&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)</span><br><span class="line"><span class="keyword">if</span>(q[hh].num[i] == aim[i])</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">9</span>) <span class="keyword">return</span> q[hh];</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line"><span class="keyword">for</span>(z = <span class="number">0</span>;z &lt; <span class="number">9</span>;++z)</span><br><span class="line"><span class="keyword">if</span>(q[hh].num[z] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>((z+<span class="number">1</span>)%<span class="number">3</span>)&#123;</span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cantor</span>(tmp.num)) q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z % <span class="number">3</span>)&#123;</span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cantor</span>(tmp.num)) q[++tt] = tmp;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z &gt; <span class="number">2</span>)&#123;</span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z<span class="number">-3</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cantor</span>(tmp.num)) q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z &lt; <span class="number">6</span>)&#123;</span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z+<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cantor</span>(tmp.num)) q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">++hh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> chtmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)&#123;</span><br><span class="line">cin &gt;&gt; chtmp;</span><br><span class="line"><span class="keyword">if</span>(chtmp == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">beg[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">beg[i] = chtmp - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;<span class="comment">//读入begin数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cantor</span>(beg);<span class="comment">//初始状态放进vis</span></span><br><span class="line">state answer = <span class="built_in">bfs</span>();</span><br><span class="line"><span class="keyword">if</span>(answer.re == <span class="number">-1</span>)&#123;<span class="comment">//如果没找到目标，输出unsolvable</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unsolvable\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(answer.re != <span class="number">-1</span>)&#123;</span><br><span class="line">ans.<span class="built_in">push_back</span>(answer.ch);</span><br><span class="line">answer = q[answer.re];<span class="comment">//一层一层向上找，把ch存入答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = ans.<span class="built_in">end</span>()<span class="number">-1</span>;i &gt;= ans.<span class="built_in">begin</span>();--i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*i);<span class="comment">//逆序输出答案</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thats all</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八数码问题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
