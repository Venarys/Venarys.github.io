<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数列极限（一）</title>
      <link href="/2024/07/09/maAnalysis-2024-07-09-%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/07/09/maAnalysis-2024-07-09-%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数学分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>埃氏筛和欧拉筛</title>
      <link href="/2024/07/09/algo-2024-07-09-%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%92%8C%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
      <url>/2024/07/09/algo-2024-07-09-%E5%9F%83%E6%B0%8F%E7%AD%9B%E5%92%8C%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h1><p>比较原始，但很实用，性价比高。</p><p>最简单的实现如下：(筛出1~N的质数)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> notp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">is</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= N;++i) </span><br><span class="line"><span class="keyword">if</span> (!notp[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>*i;j &lt;= N;j += i)</span><br><span class="line">notp[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然这有很多的优化空间，比如排除偶数、从i*i开始等等。</p><p>上面这段代码没有记录素数的数组。可以改为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> notp[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; pri;</span><br><span class="line"><span class="type">void</span> is&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= N;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!notp[i]) pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p:pri) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i*p &gt; N) <span class="keyword">break</span>;</span><br><span class="line">            notp[i*p] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里把筛去 “质数的整数倍” 变为 “整数的质数倍”，效果相同。</p><p>而且这种改法离欧拉筛就差一行代码</p><h1 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h1><p>也叫线性筛：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> notp[i];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">els</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= N;++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!notp[i]) pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : pri) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i*p &gt; N) <span class="keyword">break</span>;</span><br><span class="line">            notp[i*p] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//欧拉筛的精髓</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>每个数只筛一次<br><br>如 6=2*3=3*2。就让2先不筛它，让3去筛它。<br><br>12 = 2*6 = 3*4 = 4*3 = 6*2，实际上是6把他筛掉。<br><br>24 = 2*12 = 3*8 = 4*6 = 6*4 = 8*3 = 12*2,12去筛。<br><br>15 = 3*5 = 5*3 ，3筛掉。<br><br>这样看有点像保持第一个乘数不小于第二个乘数，且尽量保持第二个小的意思。</p><blockquote><p>i 之前被 p 筛过了，由于 pri 里面质数是从小到大的，所以 i 乘上之后其他的质数 p’ 的结果一定会被 p 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break掉就好了 ——改自OI wiki</p></blockquote><script type="math/tex; mode=display">\begin{align}&i = p*k \\&p'*i = p*(k*p')  = p*i'\\\&(p' > p) \Rightarrow (i' = k*p' > k*p = i)\end{align}</script><p>所以 i*p’ 一定会被之后的 i’*p 筛掉。</p><p>这里放一下 i 筛去的数来理解一下。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br><span class="line">3 6 9</span><br><span class="line">4 8</span><br><span class="line">5 10 15 20 25</span><br><span class="line">6 12 </span><br><span class="line">7 14 21 28 35 42 49</span><br><span class="line">8 16</span><br><span class="line">9 18 27</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卓里奇数学分析06（完备性推论-三大基本引理）</title>
      <link href="/2024/07/08/maAnalysis-2024-07-08-%E5%AE%8C%E5%A4%87%E6%80%A7%E6%8E%A8%E8%AE%BA-%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%90%86/"/>
      <url>/2024/07/08/maAnalysis-2024-07-08-%E5%AE%8C%E5%A4%87%E6%80%A7%E6%8E%A8%E8%AE%BA-%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>开门见山</p><h1 id="闭区间套引理-Cauchy-Cantor"><a href="#闭区间套引理-Cauchy-Cantor" class="headerlink" title="闭区间套引理(Cauchy-Cantor)"></a>闭区间套引理(Cauchy-Cantor)</h1><p>先来定义，再来定理。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>序列定义：以自然数为自变量的函数$f:N\rightarrow X$叫做<strong>集合 $X$ 中的元素序列</strong>，简称<strong>序列</strong>。</p><p>元素是数，就叫数列，元素是集，就叫集列。</p><p>集列套定义：一集列 $X_n$ ，若 $\forall n\in N(X_n\supset X_{n+1})$，就称其是<strong>集列套</strong></p><h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><p>对于任何闭区间集列套 $I_n$，<strong>存在</strong>一点 $c\in R$，使得 $c\in I_n$。<br><br>若 $|In|$ 趋近于无穷小，那么 $c$ 便是<strong>唯一</strong>的。</p><p>一个是存在性，一个是唯一性，注意唯一性不一定满足。</p><h1 id="优先覆盖引理-Borel-Lebesgue"><a href="#优先覆盖引理-Borel-Lebesgue" class="headerlink" title="优先覆盖引理(Borel-Lebesgue)"></a>优先覆盖引理(Borel-Lebesgue)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>覆盖定义：若 $S$ 是一集族，$Y \subset \underset{X\in S}\bigcup X$，就说 $S$ 覆盖集合 $Y$</p><p>集族就是集合的集合，之前有提过哦。</p><h2 id="引理-1"><a href="#引理-1" class="headerlink" title="引理"></a>引理</h2><p><em>在覆盖一个闭区间的任何开区间族中，存在这覆盖这一闭区间的有限子族。</em></p><p>意思差不多就是用有限个开区间肯定能覆盖一个闭区间。</p><h1 id="极限点引理"><a href="#极限点引理" class="headerlink" title="极限点引理"></a>极限点引理</h1><p>首先要引入两个定义，这两个定义我们之后会经常使用。</p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>邻域：含有点 $x\in R$ 的开区间，叫做 $x$ 的<strong>邻域</strong>；而开区间 $]x-\delta,x+\delta[$ 叫做点 $x$ 的 <strong>$\delta$邻域</strong>。</p><p>极限点：若点 $p\in R$ 的任何邻域都包含 $X\in R$的一个无穷子集，就称点 $p$ 为集合 $X$ 的<strong>极限点</strong>。<br><br>这个条件也可等价于在点 $p$ 的任何邻域内，至少含有 $X$ 中的一个不与 $p$ 重合的点。</p><h2 id="引理-2"><a href="#引理-2" class="headerlink" title="引理"></a>引理</h2>]]></content>
      
      
      <categories>
          
          <category> 数学分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卓里奇数学分析05（实数集的公理推论）</title>
      <link href="/2024/07/06/maAnalysis-2024-07-06-%E5%AE%9E%E6%95%B0%E9%9B%86%E7%9A%84%E5%85%AC%E7%90%86%E6%8E%A8%E8%AE%BA/"/>
      <url>/2024/07/06/maAnalysis-2024-07-06-%E5%AE%9E%E6%95%B0%E9%9B%86%E7%9A%84%E5%85%AC%E7%90%86%E6%8E%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="实数集的公理推论"><a href="#实数集的公理推论" class="headerlink" title="实数集的公理推论"></a>实数集的公理推论</h1><p>上次我们讲了实数的公理系统，这次我们来聊聊公理的推论。讨论完这个，我们就可以畅所无阻的使用小学二年级的数学了（）</p><h2 id="加法公理的推论"><a href="#加法公理的推论" class="headerlink" title="加法公理的推论"></a>加法公理的推论</h2><p>1.<em>实数集有唯一的零元</em><br><br>$\blacktriangleleft$ 假设存在两个零元 $0_1,0_2,0_1 \neq 0_2$ ,那么</p><script type="math/tex; mode=display">    0_1 = 0_1+0_2 = 0_2+0_1 = 0_2</script><p>矛盾，故原命题得证。$\blacktriangleright$</p><p>2.<em>实数集中每个元素有唯一的负元</em><br><br>$\blacktriangleleft$ 假设 $x$ 存在两个负元 $x_1,x_2，x_1\neq x_2$ ,那么</p><script type="math/tex; mode=display">    x_1 = x_1 + 0 = x_1 + (x+x_2) = (x_1+x) + x_2 = 0 + x_2 = x_2</script><p>得证了吧，用到的都是那四个公理。$\blacktriangleright$</p><p>3.<em>方程 $a+x = b$</em> 在 $R$ 中有唯一解 $x = b + (-a)$<br><br>$\blacktriangleleft$ 我们这里就可以借助刚刚证明的推论2了</p><script type="math/tex; mode=display">(a+x=b) \Leftrightarrow (a+(-a)+x=b+(-a)) \Leftrightarrow (0+x=b+(-a)) \Leftrightarrow (x = b+(-a))  \blacktriangleright</script><p>$b+(-a)$ 可写成 $b-a$</p><h2 id="乘法公理的推论"><a href="#乘法公理的推论" class="headerlink" title="乘法公理的推论"></a>乘法公理的推论</h2><p>1.<em>实数集有唯一的单位元</em> <br><br>$\blacktriangleleft$ 同样的，证明唯一性反证法很有用，设有两个不同的单位元$x_1,x_2$</p><script type="math/tex; mode=display">    x_1 = x_1 \cdot x_2 = x_2\cdot x_1 = x_2</script><p>矛盾，得证。$\blacktriangleright$</p><p>2.<em>对于每个非零实数，有唯一逆元</em><br><br>$\blacktriangleleft$ 设 $x$ 有两不同逆元 $x_1,x_2$</p><script type="math/tex; mode=display">    x_1 = x_1 \cdot 1 = x_1 \cdot(x\cdot x_2) = (x_1 \cdot x)\cdot x_2 = 1\cdot x_2 = x_2</script><p>矛盾。得证 $\blacktriangleright$</p><p>3.<em>方程 $a\cdot x = b$，当 $a\in R\backslash 0$,有唯一解 $x = b\cdot a^-1$</em></p><script type="math/tex; mode=display">\blacktriangleleft (a\cdot x = b)\Leftrightarrow (a\cdot a^-1\cdot x=b\cdot a^-1) \Leftrightarrow(x=b\cdot a^-1)\blacktriangleright</script><h2 id="加法与乘法附加公理的推论"><a href="#加法与乘法附加公理的推论" class="headerlink" title="加法与乘法附加公理的推论"></a>加法与乘法附加公理的推论</h2><p>1.</p><script type="math/tex; mode=display">    \forall x\in R (x\cdot 0 = 0\cdot x = 0)</script><script type="math/tex; mode=display">\blacktriangleleft(x\cdot 0 = x\cdot (0+0) = x\cdot 0+x\cdot 0) \Rightarrow (x\cdot 0 = 0)\blacktriangleright</script><p>这里可以顺便得到，$(x\in R\backslash 0) \Leftrightarrow (x_-1\in R\backslash 0)$ ，因为二者其中有一个是 $0$ ,结果必定不为 $1$.</p><p>2.<em>$(x\cdot y=0)\Rightarrow(x=0)\vee(y=0)$</em><br><br>$\blacktriangleleft$ 假如 $x \neq 0$ 那么解的唯一性可以得到 $y = 0*x^-1 = 0 \blacktriangleright$</p><p>3.<em>$\forall x\in R (-x=(-1)\cdot x)$</em><br><br>$\blacktriangleleft x+(-1)\cdot x = (1+1)\cdot x = 0\cdot x = 0$<br>又有负元的唯一性，得证。$\blacktriangleright$</p><p>4.<em>$\forall x\in R((-1)\cdot (-x) = x)$</em><br><br>5.<em>$\forall x\in R((-x)\cdot (-x) = x\cdot x)$</em></p><p>不是，哥们太多了，而且我还没有完全消化。为了写这个我已经三四天没有学习新的内容了。如果在学习的过程中一直这样怕是学不成了的。我就简短一点，不在一一写证明了。我可以在我已经学完想要有新的领悟的基础上再写点有意思的，文章或者视频都可以。现在我还是就简单写个总结吧。我真没蓝了。<br>我的水平还是够不上讲课式的风格，那我就写简单的总结吧。关键处点几点。</p><h2 id="序公理的推论"><a href="#序公理的推论" class="headerlink" title="序公理的推论"></a>序公理的推论</h2><p>主要就是把 $\leq$ 给推成 $&lt;$</p><script type="math/tex; mode=display">\begin{align}    &\forall x,y(x<y)\vee(x=y)\vee(x>y) \\    &(x<y)\wedge(y\leq z) \Rightarrow (x<z>) \\    &(x\leq y)\wedge(y<z)\Rightarrow (x<z)\end{align}</script><p>有点反人类吧，在逻辑的世界中没有直觉可言。</p><h2 id="序公理与加法及乘法公理的推论"><a href="#序公理与加法及乘法公理的推论" class="headerlink" title="序公理与加法及乘法公理的推论"></a>序公理与加法及乘法公理的推论</h2><p>加法的就是“显而易见”的等式性质</p><script type="math/tex; mode=display">\begin{align}&(x<y) \Rightarrow (x+z) < (y+z) \\&(0<x) \Rightarrow (-x<0) \\&(x\leq y)\wedge(x+z\leq y+w) \\&(x\leq y)\wedge(z<w)\Rightarrow (x+z<y+w)\end{align}</script><p>乘法的更多考虑符号的问题</p><script type="math/tex; mode=display">\begin{align}&(0<x)\wedge(0<y) \Rightarrow (0<xy) \\&(x<0)\wedge(y<0) \Rightarrow (0<xy) \\&(x<0)\wedge(0<y) \Rightarrow (xy<0) \\&(x<y)\wedge(0<z) \Rightarrow (xz < yz)\\&(x<y)\wedge(z<0) \Rightarrow (yz<xz) \\&0 = 1\end{align}</script><p>真不明白罗素和怀特海是什么心态完成的《数学原理》</p><h2 id="完备性推论-上下确界的存在性"><a href="#完备性推论-上下确界的存在性" class="headerlink" title="完备性推论-上下确界的存在性"></a>完备性推论-上下确界的存在性</h2><p>首先有很多的定义要先说明</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义1：设 $X \subset R$ 是一集合，若 $\exists c\in R,\forall x\in X(x\leq c)/(c \leq x)$,就说集合 $X$ 是<strong>上（下）有界</strong>。这时 $c$ 就叫做 $X$ 的一个<strong>上（下）界</strong>。</p><p>定义2： 既有上界又有下界的集合叫做<strong>有界集</strong> （单界无界）。</p><p>定义3： 集合 $X$ 的<strong>极大元</strong> $(a = max X) := (a\in X \wedge \forall x \in X(x \leq a))$<br><br><strong>极小元</strong> $(b = min X) := (a\in X)\wedge\forall X \in X (a \leq x)$</p><p>定义4： 集合 $X$ 的<strong>上确界</strong>为其上界中的最小者，记为 </p><script type="math/tex; mode=display">\begin{align}&(s=sup\ X) := \forall x\in X((x\leq s)\wedge(\forall s'<s\exists x'\in X(s'\leq x'))) \\or\quad &(s = sup\ X) := min\{c\in R|\forall x\in X(x\leq c)\}\end{align}</script><p>也可用符号 $\underset{x\in X}{sup}\ x$</p><p>同样的，<strong>下确界</strong>为其下界中的最大者，记为</p><script type="math/tex; mode=display">\begin{align}&(i=inf\ X) := \forall x\in X((i\leq x)\wedge(\forall i'>i \exists x' \in X(x'\leq i'))) \\or\quad &(i = inf\ X) := max\{c\in R|\forall x\in X(c\leq x)\}\end{align}</script><p>同样可用符号 $\underset{x\in X}{inf}\ x$ 表示。</p><p>定义搞完，下一步就是讲定理。</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>引理（上确界原理）：<em>实数集的任何非空有上界子集有唯一的上确界</em><br><br>人话就是有上界就<strong>有</strong> ，<strong>唯一</strong>的上确界（存在性和唯一性）。<br><br>下确界也一样，建议改成确界原理，就这，完事了</p><p>重要的是，有上界不一定有极大元，有极大元一定有上界且极大元就是上确界。下面也一样（开闭区间的意思）</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>摆了，我还有三个大引理没写呢。今晚能不能搞定呀哥。</p>]]></content>
      
      
      <categories>
          
          <category> 数学分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卓里奇数学分析04（实数集的公理系统）</title>
      <link href="/2024/07/06/maAnalysis-2024-07-06-%E5%AE%9E%E6%95%B0%E9%9B%86%E7%9A%84%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/06/maAnalysis-2024-07-06-%E5%AE%9E%E6%95%B0%E9%9B%86%E7%9A%84%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>本来是想说说公理化集合论的，可是书是写得我也不完全理解，那就等以后其它的代数书再聊吧。</p><h1 id="实数集的公理系统"><a href="#实数集的公理系统" class="headerlink" title="实数集的公理系统"></a>实数集的公理系统</h1><p>（这是我看张平老师视频的第一节课）</p><p>我们从小就开始数数，可是我们真的了解实数吗？我们现在就要从严谨的数学基础出发，重新刻画这个我们无比熟悉的老朋友。</p><p>实数的公理系统大致可以分为四块</p><ul><li>加法公理</li><li>乘法公理</li><li>序公理</li><li>完备性公理（连续性公理）<br>以及它们之间的交叉</li></ul><p>这些内容可能看起来很简单，数学家就是这么一群人，把我们的常识给生吞活剥了才算完。我们也一个一个的剥吧</p><h2 id="加法公理"><a href="#加法公理" class="headerlink" title="加法公理"></a>加法公理</h2><p>我们常说的加法，实际上是一个映射:</p><script type="math/tex; mode=display">    +:R\times R\rightarrow R</script><p>可以发现其满足以下四个性质：</p><ol><li>（中性元）有加法零元 $0,\forall x\in R$<script type="math/tex; mode=display"> x+0 = 0+x = x</script></li><li>（逆元）$\forall x\in R,\exists -x\in R$,称为$x$的负元，有<script type="math/tex; mode=display"> x + (-x) = (-x) + x = 0</script></li><li>（给合律）$\forall x,y,z \in R$,有<script type="math/tex; mode=display"> x+(y+z) = (x+y)+z</script></li><li>（交换律） $\forall x,y\in R$<script type="math/tex; mode=display"> x+y = y+x</script>这些就是我们熟悉的加法</li></ol><p>另外的，若一集合$G$上定义了一运算满足了上述1、2、3性质，就说$G$是<strong>群</strong>,若还满足性质4，就称其为<strong>阿贝尔群</strong>或<strong>交换群</strong>。</p><h2 id="乘法公理"><a href="#乘法公理" class="headerlink" title="乘法公理"></a>乘法公理</h2><p>类似的，乘法其实也是一种映射：</p><script type="math/tex; mode=display">    \cdot : R\times R \rightarrow R</script><p>其有以下性质:</p><ol><li>（中性元）存在乘法单位元 $1 \in R$，使得<script type="math/tex; mode=display"> x\cdot 1 = 1\cdot x = x</script></li><li>（逆元）$\forall x \in R\backslash 0,\exists x^-1\in R\backslash 0$<script type="math/tex; mode=display"> x\cdot x^-1 = x^-1\cdot x = 1</script></li><li>（结合律）</li><li>（交换律）</li></ol><p>后两个我就省略了嘻嘻，注意对乘法讨论逆元时，需要去掉 $0$<br><br>一般的，加法的中性元称为零元，乘法的称为单位元；加法的逆元称为负元，乘法的就称逆元。而在抽象的群里就没那么讲究了。</p><p>显然（真得很显然），$R\backslash 0$ 关于乘法是一个阿贝尔群。</p><h3 id="加法、乘法附加公理"><a href="#加法、乘法附加公理" class="headerlink" title="加法、乘法附加公理"></a>加法、乘法附加公理</h3><p>就是分配律</p><script type="math/tex; mode=display">(x+y)\cdot z = x\cdot z+ y\cdot z</script><p>另外的，若集 $G$ 上定义了如上两种运算，就称 $G$ 是一个<strong>代数域</strong>，简称<strong><em>域</em></strong></p><h2 id="序公理"><a href="#序公理" class="headerlink" title="序公理"></a>序公理</h2><p>实数是有顺序滴，严谨的说:<br><br><em>$R$ 的元素间有关系 $\leq$ ,满足下列性质：</em></p><script type="math/tex; mode=display">\begin{align}&\forall x\in R(x \leq x)           &(反身性)\\&(x\leq y)\wedge (y\leq x) \Rightarrow (x = y) &(反对称性)\\&(x\leq y)\wedge(y\leq z) \Rightarrow (x\leq z) &(传递性)\\&\forall x\in R\forall y\in R(x\leq y)\vee(y\leq x) &(线性)\end{align}</script><p>想到之前说过的“序关系”了吧。类似的，若一集合上定义一关系满足前三个性质，则称此集为<strong>偏序集</strong>，若还满足性质4，则称其为<strong>线性序集</strong>。</p><p>显然，实数集为线性序集。</p><h3 id="加法与序附加公理"><a href="#加法与序附加公理" class="headerlink" title="加法与序附加公理"></a>加法与序附加公理</h3><p>不等式恒成立</p><script type="math/tex; mode=display">    (x\leq y)\Rightarrow (x+z\leq y+z)</script><h3 id="乘法与序附加公理"><a href="#乘法与序附加公理" class="headerlink" title="乘法与序附加公理"></a>乘法与序附加公理</h3><p>同正得正</p><script type="math/tex; mode=display">    (0\leq x)\wedge(0\leq y)\Rightarrow (0 \leq x\cdot y)</script><h2 id="完备（连续）公理"><a href="#完备（连续）公理" class="headerlink" title="完备（连续）公理"></a>完备（连续）公理</h2><p>就是实数是连续的。两数之间肯定能插入另一个数。严谨表达:<br><em>如果 X 与 Y 是 R 的非空子集，而具有性质：对于任何 $x\in X,y\in Y$ ,有 $x\leq y$ ，那么，存在 $c\in R$ ，使对任何 $x\in X,y\in Y$ ，有$x\leq c\leq y$</em></p><p>为什么要冒出一个集合呢？应该是为了更好的进行推导吧。我们之后还会通过他推出许多在极限中很有用的定理。</p><h2 id="实数的定义"><a href="#实数的定义" class="headerlink" title="实数的定义"></a>实数的定义</h2><p>满足这四组条件（加法，乘法，序，完备性）的集 $R$ 称为<strong>实数集</strong>，他的元素叫做<strong>实数</strong></p><p>很严谨。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>到此为止，我们就建立了一个<strong>实数模型</strong>，我们可以放心的使用它了。几何的公理化从欧几里得时代就开始了。相比之下， 数字的公理化就要晚上许多。原因可能就在于他不如几何直观。但是他也相当重要。下面我会讲讲由这些公理推出的推论。</p>]]></content>
      
      
      <categories>
          
          <category> 数学分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学分析03（函数）</title>
      <link href="/2024/07/01/maAnalysis-2024-07-04-%E5%87%BD%E6%95%B0/"/>
      <url>/2024/07/01/maAnalysis-2024-07-04-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数的概念很多书里（如同济版高数以及高中教科书等）都是先讲到“<strong>映射</strong>”，然后用“<strong>对映</strong>”的概念去描述映射， 可是这里有一个问题，即引入了“对映”这一从未定义过的复杂概念。所以更合理的方式，是用集合论去定义函数。<br><br>我们先按书的顺序，用映射来描述一下。</p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>设有二集合$X$,$Y$，按照某种规律$f$，对于$x\in X$，$\exists !y\in Y$ 与$x$对应，就称有定义在$X$上而在$Y$取值的<strong>映射</strong>。记为：</p><script type="math/tex; mode=display">    f:X \rightarrow Y,or ,X\stackrel{f}{\longrightarrow} Y</script><p>（!在这表示唯一，<strong>唯一性</strong>是映射的重要特性）<br><br>其中$X$称映射的<strong>出发域</strong>，$y$称为映射的<strong>到达域</strong>。需要注意的是出发域不完全等于定义域，到达域也不完全等于值域<br></p><p>根据集合$X$，$Y$的性质的不同，映射有不同的名字：函数、变换、射、算子、泛函等。<br><br>其中，函数表示数集到数集的映射，算子表示函数到函数的映射，泛函表示函数到数的映射。</p><h2 id="满射，单射，双射"><a href="#满射，单射，双射" class="headerlink" title="满射，单射，双射"></a>满射，单射，双射</h2><h3 id="映射的定义域、值域"><a href="#映射的定义域、值域" class="headerlink" title="映射的定义域、值域"></a>映射的定义域、值域</h3><p>在出发域中取一集合$D$，$\forall x\in D$，都$\exists !y\in Y$ 与$x$对应，则称$D$为映射的<strong>定义域</strong>(Domain)，映射在$D$的一切元素上取得的函数值$f(x)$构成的集合$R$，称其为映射的<strong>值域</strong>(Range)，即</p><script type="math/tex; mode=display">    f(X):=R=\{y\in Y|\exists x((x\in X)\wedge(y=f(x)))\}</script><p>特别的，当映射的定义域等于出发域且值域等于到达域时，称之为“<strong>满射</strong>”</p><h3 id="像、原像与层"><a href="#像、原像与层" class="headerlink" title="像、原像与层"></a>像、原像与层</h3><p>当把函数$f:X\rightarrow Y$叫做映射时，它在<em>元素</em>$x\in D$上取的值$f(x)\in R$,通常称为元素$x$的<strong>像</strong><br><br>对于<em>集合</em>$A\subset D$，$A$中各点$x$的像所组成的集叫做A在映射$f:X\rightarrow Y$上的像</p><p>对于集$B\subset Y$，则把$X$中其像属于$B$的那些元素的集：</p><script type="math/tex; mode=display">    f^{-1}(B) := \{x\in X|f(x)\in B\}</script><p>称为$B$的<strong>原像</strong>或全原像。</p><h3 id="单射"><a href="#单射" class="headerlink" title="单射"></a>单射</h3><p>如果对$X$中的任何元素$x_1,x_2$，有</p><script type="math/tex; mode=display">    (f(x_1) = f(x_2)) \Rightarrow (x_1 = x_2)</script><p>即不同的元素有不同的像，就说$f$是<strong>单射</strong>（或嵌入、内射）</p><h3 id="双射"><a href="#双射" class="headerlink" title="双射"></a>双射</h3><p>如果f既是单射，又是满射，就称f是双射（或一一映射、双方单值映射）</p><h3 id="逆映射"><a href="#逆映射" class="headerlink" title="逆映射"></a>逆映射</h3><p>若映射$f$是双射，即集$X$与集$Y$间双方单值对应，那么自然有映射</p><script type="math/tex; mode=display">f^{-1}:Y\rightarrow X</script><p>这个映射叫做原映射f的<strong>逆映射</strong></p><p>虽然符号表示与原像类似，但<br><strong>只有双射有逆映射，而原像任何映射都有</strong></p><h3 id="复合映射"><a href="#复合映射" class="headerlink" title="复合映射"></a>复合映射</h3><blockquote><p>映射的复合运算，一方面是产生新映射的丰富源泉，另一方面又是将复杂映射分解为简单映射的一种方法</p></blockquote><p>若有二映射$f:X\rightarrow Y$与$g:Y\rightarrow Z$，且$f$定义在$g$的值域上，则可用公式</p><script type="math/tex; mode=display">(g\circ f)(x):=g(f(x))</script><p>确定$X$上的新映射</p><script type="math/tex; mode=display">g\circ f:X\rightarrow Z</script><p>所建立的映射叫做映射$f$与映射$g$（从右至左）的<strong>复合映射</strong></p><p>可以发现，映射的复合可满足结合律：</p><script type="math/tex; mode=display">(h\circ(g\circ f))(x)=h(g(f(x)))=(h\circ g)(f(x))=((h\circ g)\circ f)(x)</script><p>但一般不满足交换律：</p><script type="math/tex; mode=display">    g\circ f \neq f\circ g</script><h3 id="恒等映射与互逆映射"><a href="#恒等映射与互逆映射" class="headerlink" title="恒等映射与互逆映射"></a>恒等映射与互逆映射</h3><p>如果映射$f:X\rightarrow X$把$X$的每个元映成自身，那么就把$f$记作$e_x$，称为集$X$的<strong>恒等映射</strong></p><h4 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h4><script type="math/tex; mode=display">(g\circ f = e_x) \Rightarrow (g是满射)\wedge(f是单射)</script><p>$\blacktriangleleft$<br>若映射$f$不是单射，则$\exists x_1,x_2\in X,(f(x_1)=f(x_2))\Rightarrow x_1\neq x_2$ 即同一像的原像不唯一，那将原像映射回去时，必有$x_1$映射不到或$x_2$映射不到，与恒等映射的定义冲突，故$f$为单射.<br><br>若$f$的值域是$Y$，其又是单射，故$g:Y\rightarrow X$，为满射。<br>$\blacktriangleright$</p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><script type="math/tex; mode=display">(f:X\rightarrow Y,g:Y\rightarrow X是互逆的双射)\Leftrightarrow (g\circ f = e_x)\wedge(f\circ g = e_x)</script><p>$\blacktriangleleft$<br>由引理可知，$f,g$都是双射，复合之后得到$e_x$又保证了互逆性。<br>$\blacktriangleright$</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>前面说了，映射（函数）的概念可以用集合论来描述。为此，我们要先引入“关系”这一概念：</p><h3 id="关系的概念"><a href="#关系的概念" class="headerlink" title="关系的概念"></a>关系的概念</h3><p>由一些序对$(x,y)$组成的任一集，叫做一个<strong>关系</strong>$\mathcal{R}$<br><br>构成$\mathcal{R}$的所有序对的第一个元素组成的集$X$叫做关系$\mathcal{R}$的<em>定义域</em>，第二个组成的集叫做关系$$的<em>值域</em><br>类似映射，它也有出发域和到达域的定义。</p><p>“关系”其实是一个集合，有点好玩吧。</p><p>实际上，可以把关系理解为$X$与$Y$的笛卡尔积的子集。</p><p>常常把$(x,y) \in \mathcal{R}$写成$x\mathcal{R}y$，并说$x$与$y$用关系$\mathcal{R}$联系着 </p><p>如果$\mathcal{R} \subset X^2$，就说关系$\mathcal{R}$在$X$上给定。</p><p>有点抽象吧，下面我来举几个例子</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="对角线"><a href="#对角线" class="headerlink" title="对角线"></a>对角线</h4><p>一般的，给定在$X$上的关系$\mathcal{R}$，对角线定义为</p><script type="math/tex; mode=display">    \Delta = \{(a,b)\in X^2|a=b\}</script><p>$a\Delta b$ 表示 $(a,b)\in \Delta$，即 $a=b$</p><h4 id="平行"><a href="#平行" class="headerlink" title="平行"></a>平行</h4><p>若关系$\mathcal{R}$为平行，$X$为平面上直线构成的集，显然$\mathcal{R}$是$X^2$的子集：</p><script type="math/tex; mode=display">    \mathcal{R} = \{((a,b)\in X^2 | a平行b )\}</script><p>且其具有以下性质：</p><script type="math/tex; mode=display">\begin{align}    &a\mathcal{R}a      &（反身性）\\    &(a\mathcal{R} b) \Rightarrow (b\mathcal{R}a ) &（对称性）\\    &(a\mathcal{R} b)\wedge(b\mathcal{R} c)\Rightarrow (a\mathcal{R} c) &（传递性）\end{align}</script><p>这样子，关系这个概念就比较好理解了吧。另外的，若一个关系具有以上三个性质（反身，对称，传递），就称其为<strong>等价关系</strong>，可以用符号$\sim$表示。可以发现我们上面所说的对角线也是一种等价关系。</p><h4 id="包含于"><a href="#包含于" class="headerlink" title="包含于"></a>包含于</h4><p>设$M$是一个集合，对于$M$的两个子集$a$与$b$,它们之间只有三种可能关系<br></p><ul><li>$a\subset b$</li><li>$b\subset a$</li><li>$a\not\subset b \wedge b \not\subset a$</li></ul><p>设$X=P(M)$是$M$的一切子集的全体。$\subset$可以看作定义在$X$上的一个关系。且此关系在以下性质：</p><script type="math/tex; mode=display">\begin{align}    &a\mathcal{R}a      &（反身性）\\    &(a\mathcal{R} b) \Rightarrow (b\mathcal{R}a ) &（对称性）\\    &(a\mathcal{R} b)\wedge(b\mathcal{R} a)\Rightarrow (a = b) &（反对称性）\end{align}</script><p>这最后一个性质与平行不一样，称为反对称性，满足以上三个性质的关系被称为<strong>偏序关系</strong><br><br>偏序关系若另外满足性质：</p><script type="math/tex; mode=display">    \forall a\forall b((a\mathcal{R}b)\vee(b\mathcal{R}a))</script><p>即任二元素都可比较，则称其为<strong>序关系</strong>，定义了序关系的集合称为<strong>线性序集</strong>。</p><p>常见的序关系有$\leq,\geq$等，实际上这也是“序”名称的由来。</p><h2 id="重新严谨定义函数（映射）"><a href="#重新严谨定义函数（映射）" class="headerlink" title="重新严谨定义函数（映射）"></a>重新严谨定义函数（映射）</h2><p>前面说过，函数的重要特性是什么？唯一性。所以我们可以如此定义函数，若满足：</p><script type="math/tex; mode=display">(x\mathcal{R} y_1)\wedge(x\mathcal{R} y_2)\Rightarrow (y_1=y_2)</script><p>就称$\mathcal{R}$为<strong>函数关系</strong> </p><p>是的，函数也是一个关系，$y = f(x)$的意思其实是$(x,y)\in \mathcal{R}$。如此，我们就把函数定义在集合论上了。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>函数的本质是研究变化，在我们的世界中，变化是普遍和美丽的。艾米诺特在1918年的一篇文章<em>Invariante Variationsprobleme</em>(不变变分问题)，被认为是理论物理的基石。我们应该学会用变化发展的眼光去发现科学。</p>]]></content>
      
      
      <categories>
          
          <category> 数学分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学分析02（集合）</title>
      <link href="/2024/07/01/maAnalysis-2024-07-01-%E9%9B%86%E5%90%88/"/>
      <url>/2024/07/01/maAnalysis-2024-07-01-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>卓里奇数学分析第一章§2内容</p><p>数学分析是建立在严谨的数理逻辑基础上的，而集合论就是描述这种严谨的重要工具。许多重要概念（包括函数）都可以通过集合来给出严谨的定义。</p><p>本文主要讲述朴素集合论，集合的公理系统会后面出一章提到。</p><h2 id="集合的概念"><a href="#集合的概念" class="headerlink" title="集合的概念"></a>集合的概念</h2><blockquote><p>“所谓集合，是我们直观感到或意识到的，由确定的，彼此不同的对象联合成的整体。”   —— Cantor</p></blockquote><p>这句话不能被称作定义，因为它引用到了比集合更复杂且从未定义过的概念。我在书上貌似也没有找到关于“集合”的确切定义。或许是因为它作为一种公理性的存在，不需要我们精确定义就能被很好理解。那我们先把定义放在一旁，回顾一下高中的知识并把它拓展到本书中。</p><h2 id="集合的三个性质"><a href="#集合的三个性质" class="headerlink" title="集合的三个性质"></a>集合的三个性质</h2><ul><li>无序性</li><li>确定性</li><li>互异性</li></ul><p>我就不像之前教科书那样再举出几个例子仔细说明集合的概念了，这些东西应该大家都知道。还有“罗素悖论”，这个东西在讲到集合论公理系统中再讨论吧。</p><p>值得一提的是，在朴素集合论（就是我们现在讲的集合论）中，<strong>“类”，“族”，“集体”，“组”等字眼，也作为“集合”的同义词使用</strong>。如在覆盖概念中会用到的“集合的集合”（set of set），如果叫“集集”就有点难绷了，所以一般称之为“集族”。</p><h2 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h2><p>组成集合的事物叫做集合的元素。<br>命题：x是集合X的元素。符号表示为</p><script type="math/tex; mode=display">x \in X</script><p>其否命题为</p><script type="math/tex; mode=display">x \notin X</script><p>另外的，若$\forall x((x\in A)\Leftrightarrow(x\in B))$，则称$A = B$.</p><p>我用符号再把高中学的集合的包含表示一下吧</p><script type="math/tex; mode=display">\begin{align}    &(A \subset B) := \forall x((x \in A) \Rightarrow (x \in B)) \\    &(A = B) \Leftrightarrow (A \subset B)\wedge (B \subset A) \\    &(A \subsetneq B) := (A\subset B)\wedge (A \neq B)\end{align}</script><h2 id="集合的简单运算"><a href="#集合的简单运算" class="headerlink" title="集合的简单运算"></a>集合的简单运算</h2><p>高中就学过的子交并补，这里再补一个差集。（子集在上面）<br>设集合$A$与$B$都是集合$M$的子集.</p><script type="math/tex; mode=display">\begin{align}    &A \cup B := \{x\in M |(x\in A)\vee(x\in B)\} \\    &A \cap B := \{x\in M |(x\in A)\wedge(x\in B)\} \\    &C_MA := \{x\in M |(x\notin A)\} \\    &A\setminus B := \{x\in A |(x\in A)\wedge(x\notin B)\}\end{align}</script><p>差集的意思即是$A$中减去属于$B$的元素，也是比较好理解的。注意这里不要求A包含B。</p><h3 id="德摩根律"><a href="#德摩根律" class="headerlink" title="德摩根律"></a>德摩根律</h3><p>在逻辑一章我也有提到这个：</p><script type="math/tex; mode=display">\begin{align}    &\neg (A \wedge B) \Leftrightarrow \neg A \vee \neg B  \\    &\neg (A \vee B) \Leftrightarrow \neg A \wedge \neg B \end{align}</script><p>其在集合中的体现即为：</p><script type="math/tex; mode=display">\begin{align}    &C_M(A\cap B) = C_MA \cup C_MB \\    &C_M(A\cup B) = C_MA \cap C_MB\end{align}</script><blockquote><p>数学会奖励保留对称性的人</p></blockquote><h2 id="集合的直积（笛卡尔积）"><a href="#集合的直积（笛卡尔积）" class="headerlink" title="集合的直积（笛卡尔积）"></a>集合的直积（笛卡尔积）</h2><p>我们用圆括号$(x,y)$表示一组有序对$z$(其实就是平面上一个点)。其中$x$称作$z$的第一射影，$y$称$z$的第二射影。</p><script type="math/tex; mode=display">X\times Y := \{(x,y)|(x\in X)\wedge(y\in Y)\}</script><p>可以理解为X中的元素和Y中的元素一一拿出来对应组成序对。例子：</p><script type="math/tex; mode=display">\{1,3,4\} \times \{2,4\} = \{(1,2),(1,4),(3,2),(3,4),(4,2),(4,4)\}</script><p>乘法原理可以得到，$n$元集和$m$元集作直积，得到$mn$元集。</p><p>特别的，将两个垂直的数轴作直积，可得到平面直角坐标系（笛卡尔坐标系）。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>关于朴素集合论就简单讲这么多，下面我来讲讲函数，它定义在集合和关系上可以给人一种新的视角去看待它。</p>]]></content>
      
      
      <categories>
          
          <category> 数学分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学分析01（逻辑符号）</title>
      <link href="/2024/06/17/maAnalysis-2024-06-17-%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/"/>
      <url>/2024/06/17/maAnalysis-2024-06-17-%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="逻辑符号"></a>逻辑符号</h1><p>卓里奇数学分析第一章§1内容。</p><blockquote><p>“如果采用适合于发现的记号，……那么，思考工作就能得到惊人的简化。” ——<em>Leibniz</em><br><br>“数学是把不同实体统一命名的艺术。” ——<em>Poincaré</em><br><br>“自然界这部巨著是用数学语言写成的。” —— <em>Galileo</em></p></blockquote><p>这些都是从书中摘录的，我觉得这些名言挺有启发性的，说明符号之于数学的重要性。数学分析的摩天大楼就建立在这些符号和逻辑之上。当然也不应该过度追求符号而抛弃了理解和效率。牛顿在十七十八世纪用微积分解决了许多物理问题，而微积分上数学的严谨性直到19世纪之后才得到了严格的证明。(物理win)</p><blockquote><p>“当你要求一只蜈蚣解释他是怎样控制那么多条腿的时候，他早已学会走路了。”</p></blockquote><p>与、或、非、蕴含、等价五个基本逻辑符号就不用多说，我提一下他们的性质和规律。以及课后习题中一些逻辑规律，值得探究。</p><h3 id="优先次序"><a href="#优先次序" class="headerlink" title="优先次序"></a>优先次序</h3><script type="math/tex; mode=display">\neg,\wedge,\vee,\Rightarrow,\Leftrightarrow</script><h3 id="定义符号"><a href="#定义符号" class="headerlink" title="定义符号"></a>定义符号</h3><script type="math/tex; mode=display">:=</script><p>书中用了两个例子，第一个是引进定义：</p><script type="math/tex; mode=display">    \int_{a}^{b}f(x)dx := \lim_{\lambda(P) \rightarrow 0} \sigma(f,p,\xi)</script><p>第二个是引进简缩记法:</p><script type="math/tex; mode=display">    \sum_{i=1}^{n}f(\xi_i)\Delta x_i =: \delta(f,p,\xi)</script><p>实际上这两个例子就定义了定积分符号$\int_{a}^{b}$（不严谨地说）。</p><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p>$A \Rightarrow B \Rightarrow C$ 是 $(A \Rightarrow B)\vee (B \Rightarrow C)$ 的缩写<br><br><strong>若A始终为假，则 $(A \Rightarrow B)$ 总为真的</strong>，这一点确实有点反直觉，如果从思想政治书上的观点来讲，实践是检验认识的唯一标准，若A始终为假，则无法用实践检验。我个人还是比较赞同后面这个观点的。可能这个规定还有更深层次的原因吧。</p><p>符号是数学公理化的基础，也是是自己数学思考简化和严谨化的重要工具。</p><h2 id="习题（一些有趣的规律探究）"><a href="#习题（一些有趣的规律探究）" class="headerlink" title="习题（一些有趣的规律探究）"></a>习题（一些有趣的规律探究）</h2><p>a) &amp; b)</p><script type="math/tex; mode=display">\begin{align}    &\neg (A \wedge B) \Leftrightarrow \neg A \vee \neg B  \\    &\neg (A \vee B) \Leftrightarrow \neg A \wedge \neg B \end{align}</script><p>这两个式子也被称作<strong>德摩根律(De Morgan’s Laws)</strong>,这些逻辑的证明完全可以借助真值表完全枚举来证明。<br><br>我也看到了B站宋浩老师用家长会的例子去解释这个定律：要求A和B不同时到，就是要么A不到要么B不到，这是第一个式子；要求A和B至少一个到，就是A和B不能都不到，这就是第二个式子。</p><p>c)</p><script type="math/tex; mode=display">    (A \Rightarrow B) \Leftrightarrow (\neg B \Rightarrow \neg A)</script><p>这个式子可以叫做假言易位，也是“<strong>原命题为真，其逆否命题也为真。</strong>”这句话的意思。<br><br>原命题若为$(A \Rightarrow B)$，其逆命题为$(B \Rightarrow A)$，其否命题为$(\neg A \Rightarrow \neg B)$，其逆否命题为$(\neg B \Rightarrow \neg A)$。</p><p>d) &amp; e)</p><script type="math/tex; mode=display">\begin{align}    &(A \Rightarrow B) \Leftrightarrow \neg A \vee B \\    &\neg (A \Rightarrow B) \Leftrightarrow A \wedge \neg B\end{align}</script><p>这两个式子叫做<strong>蕴含等值式</strong>，同样的用真值表就很好证明，我在晚上查到的一种理解方式：<br><br>“不听话就要挨打的意思” 等同于 “要么听话。要么挨打”，这是第一个式子的理解，同样的<br><br>至于第二个式子，我在试图把$\neg (A \Rightarrow B)$用实例来表示的时候遇到了困难，可能是自然语言描述这个式子不是很容易，不过可以可以通过等职演算推导第二个式子</p><p>先浅尝辄止把，写的第一篇笔记就花了这么大功夫，主要还是数学公式latex打的不太熟练，以后慢慢熟练吧。数理逻辑当然不止这些，还有什么范式等值演算以及其他一大堆规律。卓里奇这本数学分析也没有提到这么多，等到离散数学部分在研究这些吧。</p>]]></content>
      
      
      <categories>
          
          <category> 数学分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回归</title>
      <link href="/2024/06/17/%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/06/17/%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="一年多了"><a href="#一年多了" class="headerlink" title="一年多了"></a>一年多了</h1><p>距离上次我的博客更新已经一年多了了呀，我也是把我这域名续上把我的博客复活了。折腾了几个小时，可算能跑了，但还是提示不安全，我也不想管了，先凑合的用吧。</p><p>高考已经结束了一个多礼拜了，我好像也缓过来了。<br>先去广州考了一个失败的考试，玩了几天就跑回家歇着了。有点累了，在家躺了好几天之后，准备开始学一点东西了。</p><p>先学<strong>数学分析</strong>吧，接下来我应该<strong>重心会放在数学和物理</strong> 上面，<em>计算机算法之类的</em>会先放在一边。</p><p>卓里奇真带劲。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缅怀Pascal</title>
      <link href="/2023/01/17/pascal/"/>
      <url>/2023/01/17/pascal/</url>
      
        <content type="html"><![CDATA[<h1 id="文艺复兴"><a href="#文艺复兴" class="headerlink" title="文艺复兴"></a>文艺复兴</h1><p>CCF在去年正式把pascal在高中竞赛中踩在脚底，那我就偏要玩玩这个语言。</p><p>现在，在网上，关于Pascal的讨论已经可以说只剩断壁残垣了。（我甚至能找到比我还大的帖子（悲）） 不是很容易找到那种系统又准确的教程了。我就到处整理学习了一下，并把他分享出来。</p><p>我也是初学这门语言，如果有些点不准确感谢纠正：）</p><p>语言细节一篇文章大概是讲不完的，那我就讲讲简单的语法吧。</p><h2 id="基本程序结构"><a href="#基本程序结构" class="headerlink" title="基本程序结构"></a>基本程序结构</h2><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="comment">&#123;程序名字&#125;</span></span><br><span class="line">.....</span><br><span class="line"><span class="comment">&#123;可以有一大堆不重要的声明&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">&#123;主要执行这里面的代码&#125;</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>begin前面的声明，如果用不上，都可以省略。<br><br>program这一句也行。</p><p>注意，<strong>Pascal不区分大小写</strong>（字符串除外）。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Pascal 中注释使用大括号括起。<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;单行注释&#125;</span></span><br><span class="line"><span class="comment">&#123;*</span></span><br><span class="line"><span class="comment">多</span></span><br><span class="line"><span class="comment">    注</span></span><br><span class="line"><span class="comment">行</span></span><br><span class="line"><span class="comment">    释</span></span><br><span class="line"><span class="comment">*&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="输入输出语句"><a href="#输入输出语句" class="headerlink" title="输入输出语句"></a>输入输出语句</h2><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>一般使用 <code>write</code> 输出<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">write</span>(<span class="string">&#x27;Hello!&#x27;</span>);    <span class="comment">&#123;输出&#125;</span></span><br><span class="line">writeln(<span class="string">&#x27;Hello&#x27;</span>);   <span class="comment">&#123;输出并换行&#125;</span></span><br><span class="line"><span class="keyword">write</span>(<span class="string">&#x27;Hello!&#x27;</span>,chr(<span class="number">10</span>)); <span class="comment">&#123;与上一行作用相同&#125;</span></span><br></pre></td></tr></table></figure><br>Pascal里可以用 chr(10) 作为换行符<br><br>chr是将数字转换为ASCII字符的函数<br><br>10在ASCII中对应换行符。</p><p>write可以输出字符串，变量等，<strong>注意字符串用 ‘ 单引号括起</strong><br><br>用 ‘,’ 隔开输出内容表示接在后面输出，一般输出不同种类数据时使用<br><br>write还可以自定义场宽（<strong>如果定义的场宽大于实际输出长度，则留空。如果小于，则按原样输出</strong>），<br>如果输出的是real类型还可以定义保留小数位数（<strong>是四舍五入</strong>）。用’:’分隔，第一个参数是场宽，第二个是小数位，如下: (<em>当然writeln也可以</em>)<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">write</span>(<span class="number">6</span>:<span class="number">7</span>);</span><br><span class="line"><span class="comment">&#123;输出:&#x27;   6   &#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">write</span>(<span class="number">6</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">&#123;输出:&#x27;6&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">write</span>(<span class="number">114.514</span>:<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line"><span class="comment">&#123;输出:&#x27;114.5&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">write</span>(<span class="number">114.594</span>:<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line"><span class="comment">&#123;输出:&#x27;114.6&#x27;，四舍五入&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>一般使用 <code>read</code> 输入<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">read</span>(<span class="comment">&#123;变量名列表&#125;</span>);</span><br><span class="line"><span class="keyword">read</span>(a,b);  <span class="comment">&#123;读入a,b 忽略空格和换行符&#125;</span></span><br></pre></td></tr></table></figure><br>还有readln()函数也可以读入。readln和read的区别是readln读入后切换到下一行，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入数据：</span><br><span class="line">1 2 3 4</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure><br>用read读入四个值<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(a,b);</span><br><span class="line">read(c,d);</span><br></pre></td></tr></table></figure><br>之后a = 1,b = 2,c = 3,d = 4;<br>而用readln读入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readln(a,b);</span><br><span class="line">read(c,d);</span><br></pre></td></tr></table></figure><br>之后a = 1,b = 2,c = 5,d = 6;<br><br>注意：</p><ul><li>变量类型与输入的数据类型必须一致</li><li>输入顺序与变量顺序要一致</li></ul><h2 id="变量及数据处理"><a href="#变量及数据处理" class="headerlink" title="变量及数据处理"></a>变量及数据处理</h2><p>要在程序var区域定义变量<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> aPlusB;</span><br><span class="line"><span class="comment">&#123;简单的A+B程序&#125;</span></span><br><span class="line"><span class="keyword">var</span> a,b:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    readln(a,b);</span><br><span class="line">    writeln(a+b);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></p><h3 id="Pascal的标准数据类型"><a href="#Pascal的标准数据类型" class="headerlink" title="Pascal的标准数据类型"></a>Pascal的标准数据类型</h3><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>表示整数<br>|类型|数值范围|占用字节|二进制意义|<br>|:—-:|:————-:|:———-:|:—-:|<br>|shortint|-128~127|1|带符号8位|<br>|integer|-32768~32767|2|带符号16位|<br>|longint|-2147483648~2147483647|4|带符号32位|<br>|byte|0~255|1|无符号8位|<br>|word|0~65535|2|无符号16位|</p><h4 id="实型"><a href="#实型" class="headerlink" title="实型"></a>实型</h4><p>表示实数<br>|类型|数值范围|占字节数|有效位数|<br>|:—-:|:—-:|:—-:|:—-:|<br>|real|2.9e-39~1.7e38|`6|11~12|<br>|single|1.5e-45~3.4e38|4|7～8|<br>|double|5.0e-324~1.7e308|8|15~16|<br>|extended|3.4e-4932~1.1e4932|10|19~20|<br>|comp|-2^63+1~2^63-1|8|19~20|</p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p><strong>boolean</strong>，也叫逻辑值。只有两个值: true or false.</p><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p><strong>char</strong>, 必须用单引号括起来。只有一个值，否则就是字符串。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>可以用string定义，也可以使用字符数组。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量(constant)在pascal中不像C中一样用const修饰变量（或者直接#define），pascal的常量在const下声明，如下：<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;求一个圆的面积&#125;</span></span><br><span class="line"><span class="keyword">const</span>  <span class="comment">&#123;在此定义常量&#125;</span></span><br><span class="line">PI = <span class="number">3.141592654</span>;</span><br><span class="line"><span class="keyword">var</span>    <span class="comment">&#123;在此定义变量&#125;</span></span><br><span class="line">r, s : real;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   writeln(<span class="string">&#x27;r ?&#x27;</span>);</span><br><span class="line">   readln(r);</span><br><span class="line">   s := PI * sqr(r);</span><br><span class="line">   <span class="comment">&#123;使用常量,sqr()是pascal求平方函数&#125;</span></span><br><span class="line"></span><br><span class="line">   writeln(<span class="string">&#x27;S: &#x27;</span>,s:<span class="number">0</span>:<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>刷OJ也没见过多少人用（bushi）<br><br>pascal的枚举类型可以用type声明一下，再在var定义一个此类型的对象使用。如下：<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">    sex = <span class="comment">&#123;male,female,yyy&#125;</span>; <span class="comment">&#123;声明枚举类型sex&#125;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    val : sex; <span class="comment">&#123;定理sex类型的变量&#125;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    val := yyy</span><br><span class="line">    writeln(<span class="string">&#x27;yyy&#x27;</span>s sex <span class="keyword">is</span> <span class="string">&#x27;,yyy);</span></span><br><span class="line"><span class="string">end.</span></span><br></pre></td></tr></table></figure><br>这个枚举变量和C语言还是有区别的，他是输出字符串而不是输出数字，因为不是很常用，这里也不深究了。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>在程序文件开头的var部分定义的是全局变量<br><br>我们当然可以定义各个函数的局部变量，在后面写到函数的时候再讲</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><strong>pascal中的赋值为 ‘ := ‘</strong>，而’ = ‘是判断相等的关系运算符。<br><br>（应该不止我一个人容易错在这）</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>进行基本算术运算。</p><p>‘+’表示加法<br><br>‘-‘表示减法<br><br>‘<em>‘表示乘法<br><br>‘/‘表示除法，<em>*但不同于C的是他返回的是实型值</em></em>，无论两个操作数是整型还是实型<br><br>如： 5 / 2 = 2.50，4 / 2 = 2.00。<br><br>‘div’也表示除法，但只能用于整型，这时相当于C中的’/‘。<br><br>如： 5 div 2 = 1,  4 div 2 = 2。<br><br>‘mod’表示取余运算，相当于C中的’%’。</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只有两个返回值，true or false.</p><p>‘=’ 判断两个操作数是否相等，相当于C中’==’。<br><br>‘&lt;&gt;’判断两个操作数是否不等，相当于C中’!=’。<br><br>‘&gt;’ 大于号，’&gt;=’ 大于等于号<br><br>‘&lt;’ 小于号，’&lt;=’ 小于等于号<br></p><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p>处理布尔操作符并返回布尔结果，像逻辑上的与，或，非</p><p>and 表示与运算 相当于C中的 “&amp;&amp;”。<br><br>or  表示或运算 相当于C中的 “||”。<br><br>not 表示非运算 相当于C中的  “!”。</p><p>至于我还在其他地方看到的and then,or else运算符，我在我的linux和win上的fpc编译器上都是过了，不行。我觉得可能是版本更新把这些东西更新掉了，但也没有找到资料。<em>有懂哥的话可以教教</em>。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>就和C中的位运算很像了。</p><p>&amp; 按位与<br><br>| 按位或<br><br>~ 取反<br><br>&lt;&lt;,&gt;&gt; 左移，右移<br><br>另外有的pascal编译器还允许not and xor shl shr等作位运算符。</p><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>有点像python中的用法，直接放代码：<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c:char;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">readln(c);</span><br><span class="line"><span class="keyword">if</span> c <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>..<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="keyword">then</span> writeln(<span class="string">&#x27; c is letters&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> c <span class="keyword">in</span> [<span class="string">&#x27;0&#x27;</span>..<span class="string">&#x27;9&#x27;</span>]</span><br><span class="line"><span class="keyword">then</span> writeln(<span class="string">&#x27;c is digits&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br>这里就用到了in运算符，if语句的语法可以看看下面的分支结构。</p><p>in运算符判断元素在不在集合里并返回一个布尔值，而这里集合的表示也是pascal比较特色的一点，也挺方便的。”..”表示整个ASCII码闭区间。另外想很多语言一样，if后的括号是可以省略的。</p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">优先级</th></tr></thead><tbody><tr><td style="text-align:center">~,not</td><td style="text-align:center">最高</td></tr><tr><td style="text-align:center">*,/,div,mod,and,&amp;</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">,!,+,-,or</td><td></td></tr><tr><td style="text-align:center">=,&lt;&gt;,&lt;,&gt;,&lt;=,&gt;=,in</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">and or</td><td style="text-align:center">最低</td></tr></tbody></table></div><p>Pascal中and or运算优先级最低，所以在if语句判断的时候就要:<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (a&lt;<span class="number">3</span>) <span class="keyword">and</span> (<span class="number">1</span>&lt;a) ) ...</span><br></pre></td></tr></table></figure><br>而不是<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a&lt;<span class="number">3</span> <span class="keyword">and</span> <span class="number">1</span>&lt;a)<span class="comment">&#123;错误用法&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="循环结构，分支结构"><a href="#循环结构，分支结构" class="headerlink" title="循环结构，分支结构"></a>循环结构，分支结构</h2><h3 id="分支-选择结构"><a href="#分支-选择结构" class="headerlink" title="分支/选择结构"></a>分支/选择结构</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;基本语法&#125;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="comment">&#123;逻辑表达式&#125;</span>)</span><br><span class="line">    <span class="keyword">then</span> <span class="comment">&#123;语句&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;还有&#125;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="comment">&#123;逻辑表达式&#125;</span>)</span><br><span class="line">    <span class="keyword">then</span> <span class="comment">&#123;语句&#125;</span>     <span class="comment">&#123;这里不能加 &#x27;;&#x27;&#125;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">&#123;语句&#125;</span>;</span><br></pre></td></tr></table></figure><p>以上只适合单行，多行需要复合语句。在pascal中符合语句就相当于C里的大括号。</p><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="comment">&#123;判断语句&#125;</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">&#123;语句&#125;</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;基本语法&#125;</span></span><br><span class="line"><span class="keyword">case</span>(<span class="comment">&#123;表达式&#125;</span>) <span class="keyword">of</span></span><br><span class="line">    <span class="comment">&#123;表达式1&#125;</span>:<span class="comment">&#123;语句1&#125;</span></span><br><span class="line">    <span class="comment">&#123;表达式2&#125;</span>:<span class="comment">&#123;语句2&#125;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">&#123;语句&#125;</span></span><br></pre></td></tr></table></figure><p>程序会计算case后表达式的值，然后看看对应第几个表达式的值，然后执行第几句语句（如果有多句记得用begin-end复合语句）。如果都没有匹配则执行else后的内容。</p><p>不像C中switch一样的是她不用在每段后面加上break或continue跳转。当然她也可以用嵌套if语句代替。</p><p>例子（懒得写了，网上复制的）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var</span><br><span class="line">   grade: char;</span><br><span class="line">begin</span><br><span class="line">   read(grade);</span><br><span class="line">   case (grade) of</span><br><span class="line">      &#x27;A&#x27; : writeln(&#x27;Excellent!&#x27; );</span><br><span class="line">      &#x27;B&#x27;, &#x27;C&#x27;: writeln(&#x27;Well done&#x27; );</span><br><span class="line">      &#x27;D&#x27; : writeln(&#x27;You passed&#x27; );</span><br><span class="line">   else</span><br><span class="line">      writeln(&#x27;You really did not study right!&#x27; );</span><br><span class="line">    end;</span><br><span class="line">   writeln(&#x27;Your grade is  &#x27;, grade );</span><br><span class="line">end.</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;基本语法&#125;</span></span><br><span class="line"><span class="keyword">for</span> 初始变量:= 初始值 <span class="keyword">to</span>/<span class="keyword">downto</span> 结束值 <span class="keyword">do</span> 语句</span><br></pre></td></tr></table></figure><p>例子：<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;求1加到100的值&#125;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    i,sum:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    sum := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">1</span> <span class="keyword">to</span> <span class="number">100</span> <span class="keyword">do</span></span><br><span class="line">        sum := sum + i;</span><br><span class="line">    writeln(sum);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></p><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;基本语法&#125;</span></span><br><span class="line"><span class="keyword">while</span> (逻辑表达式) <span class="keyword">do</span> 语句</span><br></pre></td></tr></table></figure><p>例子：<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;还是1加到100&#125;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    i,sum:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    sum := <span class="number">0</span>;</span><br><span class="line">    i := <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        sum := sum + i;</span><br><span class="line">        i := i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    writeln(sum);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br>这个是用while循环写的 $\sum_{i=1}^{100} i$ 。注意因为do后面不止一个语句，所以用到了begin,end复合语句</p><h3 id="repeat-until"><a href="#repeat-until" class="headerlink" title="repeat-until"></a>repeat-until</h3><p>相当于C里的 do..while.. 循环，不过until和while意思是反的，学过英语应该都懂。</p><p>其实就是出口条件循环，while是入口条件循环，repeat-until会执行一遍语句块再判断循环成不成立，所以语句块至少会被循环一次<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;基本语法&#125;</span><br><span class="line">repeat</span><br><span class="line">    ...</span><br><span class="line">until (循环不成立条件)；</span><br></pre></td></tr></table></figure><br>例子<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;还是算1加到100&#125;</span></span><br><span class="line"><span class="keyword">var</span> i,sum:integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    i := <span class="number">1</span>;</span><br><span class="line">    sum := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        sum := sum + i;</span><br><span class="line">i := i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">until</span> (i = <span class="number">101</span>);</span><br><span class="line">    writeln(sum);</span><br><span class="line"><span class="keyword">end</span>.</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这里有多句，但不用写begin，end。(我也不知道为什么)<br><br>但写了也没事。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Pascal有函数<strong>function</strong>和过程<strong>procedure</strong>;<br>其实就是function有返回值，procedure，相当于C中返回void的函数。<br>为了行文方便我也把它叫做函数，有的地方叫作 “过程”。</p><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>基本语法：<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="comment">&#123;函数名字&#125;</span><span class="params">(<span class="comment">&#123;参数&#125;</span>:<span class="comment">&#123;类型&#125;</span>)</span>:</span> <span class="comment">&#123;返回类型&#125;</span>;</span><br><span class="line"><span class="comment">&#123;定义区域&#125;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   <span class="comment">&#123;语句&#125;</span></span><br><span class="line">   <span class="comment">&#123;函数名字&#125;</span>:= <span class="comment">&#123;返回值&#125;</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><br>定义区域可以拿来定义局部变量等一些东西。当然也可以不写东西。</p><p>例子：<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;写个求两者最小值的min吧&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span><span class="params">(a,b:longint)</span>:</span>longint;</span><br><span class="line"><span class="keyword">var</span> res:longint;<span class="comment">&#123;局部变量&#125;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; b) <span class="keyword">then</span> res:=a</span><br><span class="line"><span class="keyword">else</span> res:=b;</span><br><span class="line">min:=res;<span class="comment">&#123;返回res&#125;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a,b:longint;<span class="comment">&#123;全局变量&#125;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">read</span>(a,b);</span><br><span class="line">writeln(min(a,b));</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br>注意，如果函数参数有多个类型，要用 ; 隔开，如<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun(ch:char ; n:longint):boolean;</span><br></pre></td></tr></table></figure></p><h3 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h3><p>就是无返回值的function,语法也就是不写返回类型和返回值的function.</p><p>为了方便解释，我在下文里也把他称作”函数”.</p><p>基本语法：<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="comment">&#123;名字&#125;</span><span class="params">(<span class="comment">&#123;参数&#125;</span>:<span class="comment">&#123;类型&#125;</span>)</span>:</span>;</span><br><span class="line"><span class="comment">&#123;定义区域&#125;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">   <span class="comment">&#123;语句&#125;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><br>例子：<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">main</span><span class="params">()</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">write</span>(<span class="string">&#x27;114&#x27;</span>);</span><br><span class="line">writeln(<span class="string">&#x27; 514&#x27;</span>);</span><br><span class="line">writeln(<span class="string">&#x27;1919810&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">main();</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br>这里我写了一个main函数，pascal是没有main函数的，我们就可以这样写一个，就可以定义main里的局部变量了。这里没有参数。所以我们写不写括号都可以。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>普通一维数组的声明语法一般是先用type定义一下，然后再在var里定义一个数组对象，如下：<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line"><span class="comment">&#123;定义一个下标从1到20的整型数组&#125;</span></span><br><span class="line">arr = <span class="keyword">array</span>[<span class="number">1</span>..<span class="number">20</span>] <span class="keyword">of</span> integer;</span><br><span class="line"><span class="keyword">var</span> </span><br><span class="line">a:arr;</span><br></pre></td></tr></table></figure><br>也可以直接定义：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:array[1..20] of integer;</span><br></pre></td></tr></table></figure><br>pascal的type部分在这里我感觉就和C中的typedef作用差不多，当然后面定理类的时候也要用到它。</p><p>pascal的下标是可以自定义的，可以定义下标从负数开始，也可以用字符和枚举作下标。</p><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><p>在pascal中我们一般有两种方式定义字符串，字符数组和string.</p><p>用string:<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line"><span class="keyword">name</span>:<span class="keyword">string</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">writeln(<span class="string">&#x27;What&#x27;&#x27;s your name?&#x27;</span>);</span><br><span class="line"><span class="keyword">read</span>(<span class="keyword">name</span>);</span><br><span class="line">writeln(<span class="string">&#x27;Hello &#x27;</span>,<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br>用字符数组:<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> testString;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line"><span class="keyword">name</span>:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">20</span>] <span class="keyword">of</span> char;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">writeln(<span class="string">&#x27;What&#x27;&#x27;s your name?&#x27;</span>);</span><br><span class="line"><span class="keyword">read</span>(<span class="keyword">name</span>);</span><br><span class="line">writeln(<span class="string">&#x27;Hello &#x27;</span>,<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br>两种方式表现区别不大，而且都可以用[]下标访问第几个元素，<br>不过有一个细节就是，string下标默认从1开始，第一个程序的name[0]没有东西。<br><br>而字符数组的第一个字符总是存在第一个下标，下标从1开始name[1]就是第1个字符；从-1开始，name[-1]就是第1个字符</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>定义语法如下：<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;定义一个400个元素的二维char数组&#125;</span></span><br><span class="line">a:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">20</span>,<span class="number">1</span>..<span class="number">20</span>] <span class="keyword">of</span> char;</span><br></pre></td></tr></table></figure><br>使用的时候可以用 a[3,4]访问元素，也可以试用a[3][4]访问元素。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>简单介绍一下吧。</p><p>在下面这个程序里我写了个sudent类，并定义了a,b两个对象。<br><br>并让他们执行一些操作。<br><figure class="highlight pas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line">    <span class="comment">&#123;类定义语法&#125;</span></span><br><span class="line">Student = <span class="keyword">object</span></span><br><span class="line"><span class="comment">&#123;public表示公有成员，像其他很多语言一样&#125;</span></span><br><span class="line">    <span class="keyword">public</span></span><br><span class="line">        <span class="comment">&#123;定义两个成员变量&#125;</span></span><br><span class="line"><span class="keyword">name</span>:<span class="keyword">string</span>;</span><br><span class="line">score:longint;</span><br><span class="line">        <span class="comment">&#123;声明一个成员函数&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Yes</span>;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;定义两个student类的变量&#125;</span></span><br><span class="line"><span class="keyword">var</span>a,b:student;</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;要在这个地方定义函数体&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">Student</span>.<span class="title">Yes</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">&#123;字符串中两个&#x27;&#x27;表示一个单引号&#125;</span></span><br><span class="line"><span class="keyword">write</span>(<span class="string">&#x27;I&#x27;&#x27;m &#x27;</span>,<span class="keyword">name</span>,<span class="string">&#x27;,I got &#x27;</span>,score,chr(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;执行部分&#125;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">&#123;把a,b赋值&#125;</span></span><br><span class="line">a.<span class="keyword">name</span> := <span class="string">&#x27;yyy&#x27;</span>;</span><br><span class="line">a.score := <span class="number">1919810</span>;</span><br><span class="line">b.<span class="keyword">name</span> := <span class="string">&#x27;senpai&#x27;</span>;</span><br><span class="line">b.score := <span class="number">114514</span>;</span><br><span class="line">    <span class="comment">&#123;a,b执行函数&#125;</span></span><br><span class="line">a.Yes;</span><br><span class="line">b.Yes;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><br>输出:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m yyy,I got 1919810</span><br><span class="line">I&#x27;m senpai,I got 114514</span><br></pre></td></tr></table></figure><br>这就是类的基本使用，简单来说就是在type里声明一个类型，后面要加上 <code>= object</code>.然后定义类的成员，然后成员函数需要在类外定义。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>就将这么多吧，还有一点关于类的构造，继承以及指针等没有讲。不过那些不是开发大项目也不是很用得上，这么多应付一些简单程序，刷刷OJ还是够的吧。（2023年不会还有人用Pascal开发项目吧）</p><blockquote><p>算法 + 数据结构 = 程序</p></blockquote><p>这句大名鼎鼎的公式便是Pascal之父Niklaus Wirth提出的。他于1984年获得图灵奖。他还提出了一句话：</p><blockquote><p>软件变慢的速度要快于硬件变快的速度</p></blockquote><p>确实，Pascal诞生于1970年，比C语言的岁数还要大。在那个计算机普遍只有几十kb内存的年代，多出1k的内存占用都是无法接受的。，于是Pascal以及ALGOL系列等语言需要严格的内存分配机制，像什么变量必须定义在程序开头呀（C语言的早期也是这么要求的）等一些语言特性，使他甚至有比C更好的编译速度和空间优势。但后来C++，java因为高级特性而牺牲部分性能，再到如今火遍天下的python已经完全成为了动态语言，我们是在变慢。</p><p>不过这换来了互联网行业的兴盛，以及编程普及的“大好形势”，上古时期，冯诺伊曼等传奇元老曾认为，用汇编语言之上的编译器编译的高级语言，拖慢程序运行速度。是傻瓜才会去用的。那也是他们老人家没有看到现在这个时代。</p><p>现在虽然各大牙膏厂在争相练习刀法（bushi），但硬件的更新速度还是有目共睹的，新代i3能打旧版i7,电脑的内存也要比几年前手机硬盘还要大了，16G内存也已经是现在笔记本电脑的标配了。（库克你个小可爱）所以我们现在有资本去丢芝麻捡西瓜。</p><p>但是，正如Anders Hejlsberg(也是一位大牛，C#, Turbo Pascal, Delphi, Typescript之父）所言，最想从那个时代继承下来的东西，便是“资源限制”。现在的程序总是把很多不必要的东西往里面塞。</p><p>国内很多人接触到Pascal都是通过信息学奥赛。Pascal虽已过气，但他实实在在的影响了国内外许多人（包括Anders）。或许未来的某一天，该语言的学习会归入考古学的范畴（乐）。又或者，根本不会有人在乎。有人说，Pascal优美的像诗，但带啊吗终究不是诗，不会被千古传颂。我们程序员写的代码，或许都会在某一天被按下del键，消失在这个世界中。或是被遗弃，或是被更好的代码替代，这是无法避免的。</p><p>幸运的是，我们还能留下思想。或许这，才是程序最核心的东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> begin &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> end &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 语法,计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>again</title>
      <link href="/2023/01/12/again/"/>
      <url>/2023/01/12/again/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="不对。" data-whm="这个文章不能被纠正，不过还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="d5f33bb93718c06066c166e08bcc1b82462dc418ec8abd7c6ce6398c09b61fbb">667af6f845cbba6975f9a13ccf0774e595d06380fa37a732f844b3230a2e5e2b5740313f4ba5e62d35e5eff91a52d48706391b0c3ec8c795b29222cfd9663e6a5386bad1c0c3d6d468b622430df1a07ef7e75d07505b3f1975a93670b48a7e305577c64ef401a6d6eb2cd613b0be8b9fbe7a8aa2c559842b42f153dc1fe0e2a9ba2d55784e05db635ab0221deedfd22c5a938836a5b7b492a786d2fe77ef79cfe0ace67cb9601609457315dfabd0f0bb2e392b792f25e32ced153b35bddfaf8cee4b26a0ca77b368b12177743aad74592ba1c3a9511af4683128b8620a3b3d4acd2e8815788ba430aa72ec03de70e7b8c1438b9574c285286bb9cbbd2d34976718680893ea7ba01a2a3a5a5ccf833d98f2cbb4ae62a433f7770a83cd6be4212dde139c04247a09f95a6a2aa82d8a97c831e1e64e9773b22b837eaa95effb92a5c83099597ad90dc626d87a9f6162720d19d0dac4ecb6b4f9089b39826aa41bb6371c84f49a98575611da8d8dd4463e28da79bcffd1f5072a6052a8b22e326edfb9300f95c77c12767f8b9ec571ef50cc156ae92b0231bae004e6bbb0cb8f45eb92a13f3fd6afcb3360b2390f7ba90c8c7f07c6e8554c828715339b471fe2b62b3fbdd001506d29a2f802b7cb1a36c5b620a6e12a2020f57946431c58a1f4ffddb57ac90adfa9fb66199683d2bde9956e34cda419f3bd1258b2cdbdf33f665d7d51f601e5b1d26cd047e0f654845cbf99d5bbab641636d8866fe18de33057308546577ab1d19e67311e7c29c8a0fca39dd8ce15d12cd5e8abdf1f1fe5f968fa23c358bbc9b8612ada869f8634b59e0bc287ba33971675f3f9d6fb533f8635d6323d9d3e46d34348ce6a05951f173acf87eec35b038a28f77a92f43ac054582d37ffacb8d52f6c228a005903d28b207bbc307545187d66016d2f0505761b6799a3a12ea06cdec9a985d5ba12cdead853bae83e5d959bc65fcc41fc200b0e4c2ff1bf0d736c0ad6433b8e9f5b5b96dfd9edb76b68d20fd99ff8cc626768ed7bf8e594d93c770d68e448ebb49da96778dc977af3dd805c9c98d7f0ba25ea03e7f4b935e5b815d5480494301560f3e73100372289f13b574ae36a012e4a83198c819d111b9c251df103c54b80a28e21ebfc04c2492ee3d807dd1c15d7c75883558b32f4731cfb84cb179db7b320e9c9f601b07126c17c561c244e2e49068ce5ec300dd16ed35ca62879b13c6511197938fbf8584f186b862d62741ff325c11cc125fcb3d02b5b77b391016f6aa66f9d2492d25c3e7f929566c9f36f021582a3ec8956600889b34eecbb13f83af267c13eb76ef55e6fed202f7b39c21076638dc334c3f174ae87c8cd254b5df1624f4f978a450ef6c3bdcdadac053b7a77e5a13f6c8661c139fb9a710ccf9d1ea4ddd78f75c396130b08790894fbd9a5e0c88878c91a143359575e608dfb895b9ffaf443be0ddba5cdcf40d1dfa88269752271d3bcce755ef64baffe8b4cf7eb53878a9508fc29797f3bb6a027360a759d8fc0b60370cd7640fb66a767cbea7b0a08072ec75487a12d7d07e98e0905dc1c37ab2a9790953c197b009a702a7ac9eb484ae140111cbb714952ba839c9b584596b38cffe3e2f46b1b4facd3b2ae368b7cb7f937a31a5acc1ad57797f04bd0b96ea32f211a02d05eb00f4588bbbb60f9a3919193c4eee463bf30b54070b689d20f3b6ee27002b65f6b00ddb18030bfe75ac4b265057094e17099e0809f1028cb76205cd47139285cedea7b55ff5b59bfb6127b8ee01994719bf3754ab8a7b1739433f393f0c76dd08dc59efe10ba4f2b28d5abd1b64e3ab9772d80a54f2e3f75d23d4e808ffb62d92e35bd7ccb69908555b9495a1d1ddf6f4163d697320c87dd0c3bff7305a4e3760609cde08b71110baf73d0ea99e14e848b5d9e50211b926fc110fd958eb59194d8a556fc29996d29e9673667d7520c9081ef12d915081f5d35c9a38e645e324aec0e95ab4bb4f33ee064874745a40c50fe39179981ff71626ed777b8c92b5bb3fcc7054091f4376b94d97405cca7f58c95218ee3a8a926f8e55ebd2d13e374d51cb56b61e011d70c98491da7ad7d5e0fd6ea2d458db193dd8b3c827487c10480e3096468fda60891016079862a769b94d2ec6964824ea03a85165c17df4c1f3689e6679f1e365e3e95e249cf9d61ce314de8951cf390af41247e586baeace77979c2cafc6e0f27795e506255d09a69c94d0279183c497b8661eedaa12e04c2799683c098b9334251f2fb52114a59fc934a47e9735d6e168a2f24fed424e3b320d26c40a9714a9d0200db57820c76b6baa8c41a2c994204aa4440c3f1b0c8cbdaf1f72dc13e9ed412e4c4b79eb1a0c8c0637565ef46ade754e6594b11903b98a5fffe030651ade77945b9d66292cb60fab6372cdec7f282f6be5c4137ba511b3902272fa8566641d311345c560916ade324f7cd546a925e5f6b328404cda43b0d38859b525a1181c1b34b660c1eeeb77ea47c9c1940fc0f6ab8a41f218346db2f75a210bd0ea604ce8d0e1a9b9326d5eef080c3ff31182fe6c57b1ca8adcfb7904c00efdcd6765cd98b6b16791deeb1b9e4c74f61353dd221140c49d0025357e3f1f5bf2a29f6cae2711e1c59e42513366bd61b9d5c27a725a7038d59990c0f5bde49247f7c052372f44de0a47f506a862d80b170a2a7147c2375544c937cd0ad7580c2e00ece508a669602b90c0d11d41a4f7ff0218d7e24b76028488d69965faef177bfdc85e392e52bc7af9d3923629c91a7e03e1a639f3543fb47dfee544843ed586be4d4d15fca577f2dcfcdb6f9b41b0d3b0f75bb32ef4f4768b0233331e028e076b48e602c17f1c13f4a40f39c981c6da7d533f2c7fb9870fb1f7d4711cf4c4447c66a0ef2e1edbb8fe1f12f0435bcc8d75982a83d09977f9fae62efc7f59c0f8b53088afb63706f1d79d388e282247bc4cfd73544d60ff474d7c1ae1fb12844640a3a9c313c630ae9482b0945c5b822d241cb8c323af2468b018cd0442ff9ac058e4c36e2a7499c20641a433c5cd97a36ffcf63cf7704e809b985836b116f6a0f2775d4464a20b976e66e4c33dd19c51dc6776393058aabaec65127c82523e778e80fbb519140db4671fa63b3465b0629cfb64fecf7702cc1bb61359448e44430120d6791cf7cd8ad3e2c10d0bf528d1a1bbe757a1ee1f042dbb1882cb0879e35858a9e57809f55853e309da26d1c0056847a9f4592d62694a0a661ba127fa685e3bd4f2a402d68f8081880aa6a678fa63b4ef4208d8c240853c643eccb4487836f7cc41c4600084d3447c659855173f1050e2b18167526dc02fb496b2470a975c8479c04bcc3411682834f68f564793f4e49fdade11c65da1bb88d7da1bd4aacedd27a014b8cd826d577266ae7b0dcceeb3b6b808bc88a9da07ff732b0e0deac27fd36b2be70c1c5cf1c87bcc0683ac3cc8b35647c44a44d9fc56ba1f4ad643fae33393935c1bc8bea16367ed0803377fef1b8c769278676250a80d7b5fbd249a3666e063d61f43b2e1a6243e7214d82405ba27452317e80665bfb725fdb073d865dd17f3843a3675ef2b0cf02b478ee881a5b8000aa58ec038deaf3b59a058551aadc0a708fd42cefec1f5ab4b355ed8c7f40e7886167ae7ee1d9c1b2a887412d6727457f65593d1fddf36d1a7763a95498d1ee76890b52a84898fe0608ebcd07766aac6a204dc7cc6e29310d49fb8f2d0a4b8d2171f9597cd057d8b7425081ec43970fa1acbf00bc788d4d417a0a5bb8c48caa0cc5d0b5c5c47a86d18c16cc5124e0b9b40a41f049d63354b86820a71da0fc96187a229d1d8aabbe6f0037d4b96de3bc516c9cb59275c52b2cdca31804b8b1c4a4ab2cd532accfd4a3553413a0c71b50d849d7cf069cb52370feaea8137e33bc6974a724548d949c23a48ca4c12d057cae14094b6364be59395adf4ca3ab2bf048d5a4090a9098156bb1a7a05fd47d7610ab38289467c162feda0b6a98e6f7d1b971af95da9fb837b5f848368baee09991f989b45eebb3164ad14d9f5b2b9783527fa38d03</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">就不给你看。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瞎写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yyy的码风标准</title>
      <link href="/2023/01/04/yyy%E7%9A%84%E7%A0%81%E9%A3%8E%E6%A0%87%E5%87%86/"/>
      <url>/2023/01/04/yyy%E7%9A%84%E7%A0%81%E9%A3%8E%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<h1 id="yyy的码风标准"><a href="#yyy的码风标准" class="headerlink" title="yyy的码风标准"></a>yyy的码风标准</h1><p>为什么会有这种文章。<br>因为改码风好累。<br>就定一个标准吧，以后不乱改了</p><ol><li>不用iostream！！速度至上</li><li>不用<code>using namespace std;</code>，我觉得::很有C++的感觉</li><li>下标从1开始，方便数学表示；如用stl则从0(begin())开始</li><li>区间左闭右闭，如有stl则左闭右开</li></ol><p>就这四项基本（抖机灵）标准吧。</p><p>还是随缘吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> OI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语法易混点（const修饰符，引用）</title>
      <link href="/2022/12/30/C-1/"/>
      <url>/2022/12/30/C-1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-语法易混点（const修饰符，引用）"><a href="#C-语法易混点（const修饰符，引用）" class="headerlink" title="C++语法易混点（const修饰符，引用）"></a>C++语法易混点（const修饰符，引用）</h1><p>来讲讲C++中几个易混的点：<strong>const修饰符到底怎么用</strong>，<strong>引用&amp;的使用</strong></p><h2 id="const修饰符"><a href="#const修饰符" class="headerlink" title="const修饰符"></a>const修饰符</h2><h3 id="声明常量"><a href="#声明常量" class="headerlink" title="声明常量"></a>声明常量</h3><p>在C语言里我们曾经常使用#define预处理命令声明常量，在C++我们被建议使用const修饰符。<br>如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">114514</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.142</span> </span><br></pre></td></tr></table></figure><br>这样我们就可以声明常量了，如果我们尝试修改就会报错。</p><h3 id="修饰指针"><a href="#修饰指针" class="headerlink" title="修饰指针"></a>修饰指针</h3><p>这就是一个很多人经常搞不明白的一个点了，const修饰的指针有两种，如下：(<em>x为已声明的变量</em>)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p1 = &amp;x;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p2 = &amp;x;</span><br></pre></td></tr></table></figure><br>const放int<em>前面，为 <strong>“指向const的指针”</strong> ，但是他是可以指向非const变量的，只是我们<strong>不能通过该指针去修改变量的值</strong>，如`</em>p1 = 3<code>这种操作就会报错。不过可以修改指针的值。如</code>p1 = &amp;y`是被允许的。</p><p>const放int<em>后面，为 <strong>“const指针”</strong> ， 说明这个指针的值是不能被修改的，即<strong>所指的地址是不能被修改</strong>的。（一生独一)。但我们可以通过该指针修改变量的值，如`</em>p1 = 3<code>是被允许的，而</code>p1 = &amp;y`就是不行的。</p><p>当然，只要你想，你还可以这么定义指针：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3 = &amp;x;</span><br></pre></td></tr></table></figure><br>不过是上面两种结合而已。</p><h3 id="修饰函数形参"><a href="#修饰函数形参" class="headerlink" title="修饰函数形参"></a>修饰函数形参</h3><p>如我们要定义一个打印A类型的函数，我们可以这么写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> A&amp; x)</span></span>;</span><br></pre></td></tr></table></figure><br><strong>const修饰符修饰函数形参时就说明，函数不会修改该参数的值</strong>。当我们引用传参（pass by reference）时，可能会不小心修改参数的值，当你加了const修改就会报错，但不加const，也不修改参数的值，也不会报错。但这是一个编程好习惯，让人更清楚程序在做什么，所以写接口之前最好想清楚会不会修改参数的值。<strong>能用const尽量const。</strong></p><h3 id="修饰函数返回值"><a href="#修饰函数返回值" class="headerlink" title="修饰函数返回值"></a>修饰函数返回值</h3><p>当函数返回值为引用时，我们可以将函数作为左值，这一点我们经常在编写类的时候使用。</p><blockquote><p><em>代码参考知乎用户 学鶸</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num):<span class="built_in">data</span>(num)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">get_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">get_data</span>()=<span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_data</span>() &lt;&lt; endl; <span class="comment">//data=3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样我们就修改了a.data的值<br><strong>这时如果我们不想把函数作为左值</strong>，也就是不想通过这个修改成员变量的值，可以把返回值声明为const，写成<br><code>const int&amp; get_data()&#123;……&#125;</code>这样子。我们<strong>重载赋值运算符时</strong>经常使用。</p></blockquote><p>当然不返回引用的时候也可以用const修饰，不过没什么用,主要是可以避免像：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a + b) = c</span><br></pre></td></tr></table></figure><br>这种情况发生。</p><h3 id="修饰类对象"><a href="#修饰类对象" class="headerlink" title="修饰类对象"></a>修饰类对象</h3><p>和const修饰基本类型常量一样，说明了类对象不能被改变。区别只在于:<br>类对象的 “改变” 定义：<strong>改变任何成员变量的值，或调用任何非const成员函数</strong>。</p><p>改变成员变量的值好懂，下面讲讲const成员函数</p><h3 id="修饰成员函数"><a href="#修饰成员函数" class="headerlink" title="修饰成员函数"></a>修饰成员函数</h3><p><strong>放在函数参数列表（小括号）后面</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num):<span class="built_in">data</span>(num)&#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//const 修饰成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">get_data</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无const 修饰成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_data</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">        data = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//const 修饰成员函数,但修改数据成员，是不被允许的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_data_bad</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        data = x;</span><br><span class="line">    &#125;   <span class="comment">//invalid</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">    A x;</span><br><span class="line">    <span class="type">const</span> A y;</span><br><span class="line"></span><br><span class="line">    x.<span class="built_in">set_data</span>(<span class="number">5</span>);                  <span class="comment">//valid</span></span><br><span class="line">    cout &lt;&lt; x.<span class="built_in">get_data</span>() &lt;&lt; endl;   <span class="comment">//valid</span></span><br><span class="line"></span><br><span class="line">    y.<span class="built_in">set_data</span>(<span class="number">5</span>);                  <span class="comment">//invalid</span></span><br><span class="line">    cout &lt;&lt; y.<span class="built_in">get_data</span>() &lt;&lt; endl;   <span class="comment">//valid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码所示，<strong>const 类对象不能执行非const成员函数</strong>。<br>如<code>y.set_data(5);</code> y是const对象，所以不能执行非const成员函数<code>set_data</code>。<br><strong>const修饰的成员函数也不能修改该成员的数据</strong>。如<code>set_data_bad()</code>这个函数就是错的</p><p><strong>const修饰成员函数的本质就是修饰了this指针</strong>，像<code>const A this</code>一样，断了在该成员函数中通过this指针修改此对象其他数据的念想。</p><h3 id="const-修饰静态类成员"><a href="#const-修饰静态类成员" class="headerlink" title="const 修饰静态类成员"></a>const 修饰静态类成员</h3><p>在编写类的时候可能需要一个<strong>类中通用的常量</strong>，我们可以用枚举（enum）实现，但现在更流行的方式是通过const修饰。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> N = <span class="number">12</span>;<span class="comment">//静态类常量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> num):<span class="built_in">data</span>(num)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">get_data</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这样子，我们在所有该类对象都能使用N这个常量了。</p><h2 id="引用-amp-的用法"><a href="#引用-amp-的用法" class="headerlink" title="引用(&amp;)的用法"></a>引用(&amp;)的用法</h2><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>引用传参可以<strong>提高效率</strong>，还可以实现C++很多类特性(比如基类指针或引用可以指向派生类)，以及<strong>修改参数的值</strong>，如果不希望修改参数的值，可以用const限定参数，如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_data</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span>;</span><br></pre></td></tr></table></figure></p><h3 id="做返回值"><a href="#做返回值" class="headerlink" title="做返回值"></a>做返回值</h3><p>参见上面const修饰函数返回值。</p><p>就讲这么多吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++, 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LIS LCS 以及相应DP模型的拓展 (一)</title>
      <link href="/2022/12/04/algo-2022-12-04-LCIS/"/>
      <url>/2022/12/04/algo-2022-12-04-LCIS/</url>
      
        <content type="html"><![CDATA[<h1 id="LIS-LCS-以及相应DP模型的拓展-一"><a href="#LIS-LCS-以及相应DP模型的拓展-一" class="headerlink" title="LIS LCS 以及相应DP模型的拓展 (一)"></a>LIS LCS 以及相应DP模型的拓展 (一)</h1><p>本来只是想写一篇题解，但总喜欢扯得太远，那干脆定一个大点的题把这些都包括进来吧。可能废话比较多，但有时间还是看看吧，说不定能有什么新思考<br>本文主要讲讲最长递增子序列（LIS），最长公共子序列（LCS）以及一些拓展dp问题。当然这些问题有的不止有dp解法。</p><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><blockquote><p>给定一个数列 $a_i$，求他们的最长严格递增子序列。<br><br>可见<a href="https://acm.hdu.edu.cn/showproblem.php?pid=1257">HDOJ-1257</a></p></blockquote><h3 id="LIS的求法"><a href="#LIS的求法" class="headerlink" title="LIS的求法"></a>LIS的求法</h3><p>当让我们也可以不求严格递增只求递增，递减也行，主要思想是一样的。<br>这里再给出两个概念</p><blockquote><p>子序列：把一个序列 $a_i$ 删除某些元素得到的序列 $b_j$,称 $b_j$ 为 $a_i$ 的子序列</p></blockquote><p>注意把子序列和子串的概念区分开，子串是连续的，子序列可以不连续。但他们的相对位置都没有发生变化，序列 $a_i$ 中 $m$ 在 $n$ 的后面，子序列和子串中还是 $m$ 在 $n$ 的后面。</p><blockquote><p>严格递增序列：一个序列 $a_n$，对于任意的 $1 \leq i &lt; j \leq n$，都有 $a_i &lt; a_j$</p></blockquote><p>通俗的讲就是一个序列，后面的数都要比前面的数大，注意严格是 $&lt;$ 不是 $\leq$的意思，$\leq$ 叫做递增，不叫严格递增。</p><h4 id="朴素"><a href="#朴素" class="headerlink" title="朴素"></a>朴素</h4><p>那这问题怎么做捏。<br>首先思考朴素做法，对于数列中的每一个数，暴力搜索以她为结尾（为开头也可以）的严格递增子序列长度，取最大值。时间复杂度为 $O(2^n)$ 蛮难绷住的。上个代码（注意这里展示的代码都是针对LIS，不是针对HDOJ-1257的）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">//a数组存序列,ans存答案</span><br><span class="line">int n,a[1314520],ans;</span><br><span class="line">//计算以a[i]结尾的上升子序列的长度，并更新答案</span><br><span class="line">void dfs(int i,int len);</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">//读入数组</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i = 1;i &lt;= n;++i) cin &gt;&gt; a[i];</span><br><span class="line">//枚举子序列的结尾a[i]</span><br><span class="line">for (int i = 1;i &lt;= n;++i) dfs(i,1);</span><br><span class="line">//输出答案</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void dfs(int i,int len)&#123;</span><br><span class="line">//枚举每条路</span><br><span class="line">for (int j = 1;j &lt; i;++j)</span><br><span class="line">//如果这条路合法，就搜她</span><br><span class="line">if (a[j] &lt; a[i]) dfs(j,len+1);</span><br><span class="line"></span><br><span class="line">//更新答案</span><br><span class="line">ans = max(ans,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这是很慢的代码，随机数据测试发现，序列长度132个的就得跑6秒。当然是行不通的（TLE）</p><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><p>思考改进，我们可以发现dfs效率慢的原因就是重复搜索了很多状态，理论上我们可以用记忆化搜索来优化，记忆化搜索其实已经就是动态规划了。（以后有空我再展开说说这一块）但这个dfs不是单纯的返回某个值，而是不断更新全局最大值，所以不好实现记忆化搜索，我们直接尝试dp。</p><blockquote><p>能用dp三个必备要素：最优子结构，无后效性，子问题重叠</p><p>_Future  never  has  to  do  with  past  time  ,but  present  does_.</p></blockquote><p>然而我们使用dp时还是凭经验行事比较多，甚至上面一些“必备要素”不满足的情况下我们还有处理方法（挖坑）。</p><p>我们考虑dp状态的时候一般有两条路可以走，一是从阶段，状态，决策去考虑，这种类似于递推思想，二是从集合的角度思考问题，一个状态看成一个集合，考虑他包含了什么子集，这种就类似于递归的思想。不过这只是思考方式，dp的代码实现其实都是可以递归和递推相互转化的。本质也可以从图论的角度思考（多扯一些）。</p><blockquote><p>动态规划对状态空间的遍历构成一张有向无环图，遍历顺序就是该有向无环图的一个拓扑序</p></blockquote><p>上面的东西有点深了，初学不理解没有关系，可以以后慢慢回味</p><p>我们尝试从集合的角度思考问题（我觉得这样比较直观）。</p><ol><li>首先考虑状态表示，这一步还是比较吃经验的（多刷题），在这种序列dp里面，我们状态表示都离不开序列的下标。再结合上面暴力搜素的代码，这题我们直接用 $f_i$ 表示以 $a_i$ 结尾的最长递增子序列的长度。</li><li>再思考状态计算，观察这个状态包含了什么子状态，即这个状态能有什么其他状态推过来。可以发现至少这个状态不会和 $i$ 之后的状态有关（也是无后效性），从集合划分考虑状态计算，$f_i$ 包含了不选上 $a_i$ 和选上 $a_i$ 两种子状态，不选上 $a_i$ 的状态就是 $i$ 之前的最长上升子序列的长度，表示出来就是 $\max\limits_{1 \leq j &lt; i} f_j$，而选上的状态就是再加个一，即 $\max\limits_{1 \leq j &lt; i} f_j + 1$。但还要注意的一点是，不是什么时候都可以选上的，要满足递增必须要满足 $a_j &lt; a_i$。两个状态取max，即最后我们推理出来的状态转移方程为<script type="math/tex; mode=display">f_i = \begin{cases}\max\limits_{1 \leq j < i} f_j + 1&\text{$a_j < a_j$},\\\max\limits_{1 \leq j < i} f_j&\text{$a_j \not< a_j$}\end{cases}</script>把 $f_i$ 全都初始化 $1$ （即以当前 $a_i$ 结尾的数的LIS长度至少为 $1$）等价变形简化一下可得(至少他们在算法实现中是等价的)<script type="math/tex; mode=display">f_i = \max\limits_{1 \leq j < i,a_j < a_i} (f_i ,f_j+1)</script>然后就可以写程序了捏，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1314520;</span><br><span class="line">int a[N],f[N],n,ans;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i = 1;i &lt;= n;++i) cin &gt;&gt; a[i],f[i] = 1;</span><br><span class="line"></span><br><span class="line">//递推，开始dp</span><br><span class="line">for (int i = 1;i &lt;= n;++i)</span><br><span class="line">for (int j = 1;j &lt; i;++j)</span><br><span class="line">//如果a[j]能选，更新答案</span><br><span class="line">if (a[j] &lt; a[i])</span><br><span class="line">f[i] = max(f[i],f[j]+1);</span><br><span class="line"></span><br><span class="line">//注意最后答案不一定是以a[n]结尾，所以要遍历一遍取最大值</span><br><span class="line">for (int i = 1;i &lt;= n;++i) ans = max(ans,f[i]);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间复杂度为 $O(n^2)$ 已经比暴力快了很多了。不够我们还有更快的 $O(nlogn)$ 的方法</li></ol><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>此做法基于贪心，大致做法就是维护一个数组，并从前往后扫描数组。先讲讲这题最少拦截系统的题解可能更容易理解。</p><h3 id="HDOJ-1257题解"><a href="#HDOJ-1257题解" class="headerlink" title="HDOJ-1257题解"></a>HDOJ-1257题解</h3><blockquote><p>某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.</p><p>(8 是导弹总个数).<br><br> input:     8 389 207 155 300 299 170 158 65<br><br>输出拦截所有导弹最少要配备多少套这种导弹拦截系统.<br><br>output:     2</p></blockquote><p>怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.</p><p>简要意思就是导弹只能往下打或保持高度不变，所以求的就是至少要多少个不上升子序列能覆盖整个序列。其实球的就是原序列的LIS长度，证明来：</p><blockquote><p>我们如果求出了这些覆盖原序列的最长上升子序列，如样例里的{389,207,155}和{300,299,170,158,65}。那我们肯定能在后一个序列中找到一个数，和前一个数构成上升子序列，否则后一个序列应该接在前一个的后面。得证</p></blockquote><p>也不复杂，所以这题就是求LIS的裸题，可以用上面讲的方法求LIS。但从这题我们可以发现LIS的个数求的就是至少要多少个不上升子序列能覆盖整个序列。所以很自然想到贪心做法。维护一个数组 $d_n$ ，并从前往后扫描数组 $a_n$ 。如果当前数 $a_i$ 比数组 $d_n$ 末尾的数还要大，就把她作为数组末尾元素，数组长度加一。否则就在数组 $d_n$ 中查找第一个大于她的数 $d_k$ ，把  $d_k$ 换成 $a_i$ （即把这个导弹用目前最低位置的拦截系统拦截掉）。我们还可以用贪心的决策包容性去解释这种做法。最后数组长度就是原序列LIS的长度。容易发现数组始终是单调递增的，所以可以用二分优化。总的复杂度为 $O(nlogn)$的。上代码：(注意代码针对的是LIS，不是题目)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">//用一个MAXN宏更方便</span><br><span class="line">#define MAXN 1000010</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">//定义变量</span><br><span class="line">int n,a[MAXN],d[MAXN],len,x;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1;i &lt;= n;++i) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">//len初始为1，这里我们下标从1开始</span><br><span class="line">len = 1;</span><br><span class="line">    d[len] = a[1];</span><br><span class="line">    for (int i = 1;i &lt;= n;++i)&#123;</span><br><span class="line">        if (a[i] &gt; d[len])</span><br><span class="line">            d[++len] = a[i];</span><br><span class="line">        else&#123;</span><br><span class="line">//查找d里第一个不小于a[i]的数，将他替换</span><br><span class="line">//即把导弹接它后面</span><br><span class="line">            x = lower_bound(d + 1,d+len + 1,a[i]) - d;</span><br><span class="line">            d[x] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们基于贪心的 $O(nlogn)$ 做法。我们从题目出发想到了这种做法，属于是ACMer促进CS发展（）。</p><p>说回DP，我们可以基于LIS的dp思想：用 $f_i$ 表示当前状态，可以由  $i$ 前面的状态得到。我们来试试其他类型的问题</p><h2 id="最大上升子序列和"><a href="#最大上升子序列和" class="headerlink" title="最大上升子序列和"></a>最大上升子序列和</h2><blockquote><p>给定一个数列 $a_i$，求他们的最大的严格递增子序列的和<br><br>注意最大的上升子序列和不一定是LIS的和</p></blockquote><p>还是和LIS一样，我们用 $f_i$ 表示以 $a_i$ 结尾的最大上升子序列和。那状态计算呢，很简单，这里直接给出，可以思考一下:</p><script type="math/tex; mode=display">f_i = \begin{cases}\max\limits_{1 \leq j < i} f_j + a_i&\text{$a_j < a_j$},\\\max\limits_{1 \leq j < i} f_j&\text{$a_j \not< a_j$}\end{cases}</script><p>即</p><script type="math/tex; mode=display">f_i = \max\limits_{1 \leq j < i,a_j < a_i} (f_i ,f_j+a_i)</script><p>所以只要把上面dp的代码改一个数字，问题就解决了，这里就不上代码了。</p><h2 id="登山"><a href="#登山" class="headerlink" title="登山"></a>登山</h2><blockquote><p>五一到了，PKU-ACM队组织大家去登山观光，队员们发现山上一个有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？<br>详见 <a href="http://noi.openjudge.cn/ch0206/1996/">noiOJ-1996</a></p></blockquote><p>当然我们可以用这种方法求最长上升子序列，当然也可以最长下降子序列（LDS）。我们可以改个符号判断，也可反着求一遍LIS。</p><p>而这题，我们就可以枚举每个点，求以这个点以这个点开始下山，即以这个点为顶点，能浏览的景点数，取个max即可。求景点数就只要求以这个点为结尾的LIS长度和以这个点为开头的最长下降子序列长度就行。如上所说，正反求两边LIS即可，上个代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1024;</span><br><span class="line">//f[i]存以a[i]结尾的LIS长度</span><br><span class="line">//g[i]存以a[i]开头的LDS长度，</span><br><span class="line">// 即倒过来的a[i]结尾的LIS长度</span><br><span class="line">int f[N],g[N],a[N],n,ans;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">//读入数列</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 1;i &lt;= n;++i) cin &gt;&gt; a[i],f[i] = 1,g[i] = 1;;</span><br><span class="line">    </span><br><span class="line">//正着来一遍dp求LIS，求f[i]</span><br><span class="line">    for (int i = 1;i &lt;= n;++i) for (int j = 1;j &lt; i;++j)</span><br><span class="line">        if (a[j] &lt; a[i]) f[i] = max(f[i],f[j]+1);</span><br><span class="line">    //反着再来一把遍，求出g[i]</span><br><span class="line">for (int i = n;i &gt;= 1;--i) for (int j = n;j &gt; i;--j)</span><br><span class="line">        if (a[j] &lt; a[i]) g[i] = max(g[i],g[j]+1);</span><br><span class="line">    </span><br><span class="line">//最后枚举顶点，能浏览的景点数就为f[i]和g[i]的和</span><br><span class="line">//因为这么加起来还多加了个自己，所以减去1</span><br><span class="line">    for (int i = 1;i &lt;= n;++i) ans = max(ans,g[i]+f[i]-1);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>好了，这就是LIS的dp了，就讲到这里吧，我们接下来讲讲最长公共子序列LCS</p><p>来不及写了，先这样吧，下周回来再讲</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些思考</title>
      <link href="/2022/12/02/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/2022/12/02/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="不对。" data-whm="这个文章不能被纠正，不过还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="acf2e42c4347445c1fe99b387e85819d8a58da811fa11a02c1904826823f0431">667af6f845cbba6975f9a13ccf0774e5aa6384887374e44c810693b3bbbae6c5182bb8b8045c26e2608e357cc293baf567b55dbf7a7695837614884eb972b83735660eb441599b066d0c288ffd7dc749d3b9808a596429c806e564283557a512dd410f0c4169a4458e9ca043f02df20e267248d4be84231382365425be421f50d7553ff390ceaa08395519a4e28de4d17770330f9d5f64400a632175e7ab30af12f59676ac89aed2a2963425fab3731092cb5952648c342484fe5def886d0a78f9d7ee85be1dab42bac2ec4c768cdb55cbfc2aa810cfb76f19cc8c85ea9a70418cfdbab89811d1f8897246accd5d5538b6b1f5cc505864a38e4342016c622119db031887ecf869931ae7cd5889f64e8d6b5184f79271ec7c8d101c63ae27571864e7dda19dffd83c211052d21daf7d7c8a1f88afd2e1528ca2671a520909f5f00bf351743a39a5791e8f167a91d35a68fefd3175fe9917af95d6f85f0488576a4aa8e6c78daa50b250bffaf29d677dd2670f61551f4ae8f398ab239ace9a2a76cc58cdc63eff65e31197bd6b1c3790733af9ac1f2afe7542b03560a647fee6063950d80d30f8468a4ba051a23756b2654096762185bd74324556ae2d6cddbba015e7553e0daa197996b277002c32697b5b2255f3812be2dbd1068ec080e9c06770dde51afdf0ed67aeeac75ac3e9c42d0166deac887d7bd820a8a760c5e25986ead41102916ad1db24a7ba93b0045c729d80e4008b22214bd1d28c5daed5af33f2244b94a50ca254c4f0db05127ab0d677d2690525724b0aa816494f4fa53a8a8d04592d9818d37df3961165a939dc939aeda111e03b17f08037f4005cf975fe717e36c972b9ac259c18cb7c74b01ea61e0d66d893ae9e42f6a9df874b2d0874a0345f3ce50b7933bebff0820a7b9443ab0cb5a052b3928057023fdf5b231d8759ebc8fa7f14d5d105a214429bd8c8e5fa9af0538cf531a61ca3773b2767710c3a0bda01c5fbf28a225a9cc8fdfdb6444f57c6460f32fc09a4bfad7d92d25cadc68e422de8baec7c229b3f606bfd932821878f3ad35cf33c668a4738fd15618311902042dbf7ccd567897ec0f2543dc1802367355f04d640d6bc012a88424c18cf0bd9ff012a12c0be290551ff509d8975530d6944d742dc9d0d1eafd5ab9a3316f336f055c6a47c500c66aac2b0d6891c23f8005a05af12b1ae954c68e8cca3d75860222b14d02afb39c17f813e06dfa90aa0147969b531bc3f6978b37e3386693d1c33bd7d01a21e0ff5b0f902846b2e81f4c6a95b3d68db356c15695fc898fe91a45a9ab2f57a6cc395fecd45ffb95b00b1b9f85ecbc4fd5a1be3582ec91fc0446f4977520d07bdd29693d761418722cceee9ba652f988368a1e8e47f7b77a62ac753ad8a18fcbf5fc73fb9536205e87678bc233f4400beb687e50700e0be1573aec24db689601f34824153c02fd2e0f789839caeaf0e20b4a89ba97f712e864821f1ef65cb0cabd0e4dc97d58b354c00eecaeb2d05d638f2bab32e5b36825431ad09c87aa1559fe4f1c4631cc97a86ecfe1b5b036d5b520a5094a0974a31a27deb28e26fee6a2467d1a6e355622b8cba80775572485d993b1a1622833e13f327636427eb2f5205eb905582f0fe17274587d9a03c2ef0ff693ca685e34be22386390eb425f1d35d02dc381ddbe68814cfb360ee9d59a865e6b5f7ce390b4af85573f79c77f393501ee448319ce7cc6e0a0f63c21c0755b48c86bac85f22581ea8118b1c63ea42c7b566127b27342e0f49d7924ec93ad2fff8db1d297578f59689cd2b82527de120eb2348e92a772c5d18e516eda8c1842f502ac7791e0122a20830217007d2cf56bbe8c6b0d74482ce449986086ac9be82fd4f08ef362500bfc15d9a8520a538865c61585547ab111e61e36ea4225b8940d371aa6c3aa339559b0a4e21c2dd099690a26caf3beefea295e68441281027da2172a15daa477d09621db71f2476cc16739b2eaa614f3f0ff049f28da8322217e12ee16622abd8f1c3559d341b026e4a5fe29cf5e0da8c5ed9a72e1ee306e82734ba6b0c662b8ce7d09ac02e2ec807a0495db91231fde6194cb94cb0bb1dacde9efaf9832a1e47f486e195e1ed3b43ad5fa3714686e7a0fcaeebc69b310ed98c1dc78f813d33bd17cd83798ec290d28337cf0ec5b66714644ea8aab915a1ed6e36c883ecd8d10e80538a3edd85ea131805461446708c9981d908b4ae6bb987ea68c6b5ff8a5e8ecf56504c6bb709027b676a93961a5ccb68159097fefc25c0dddcc96aa0f7b243f508f36e811c1e142a71ff9984dce0ca632079d33fff9f9cc9a95c3d7900a0df582dbad890ef34c86520a2d704375cb0f3a9e341493abb199566963fb3181d7bd785770c3faddbe4c03e3870bc0127ca154df32bd2672159e896116273537023c71cf89a3bcdf36def25d967f54cf8d109fea882171e76f824ca77be23e6f61d439da344eaa118c7160c934eb4eadff0953e867986928322d129e3df449536bcf207a7969a9da938c7224a090467fcb9caf29356e781551151b4fc4382e960eecdcb534911f73075c018c74f46151c14e5f184e4e876b7553e8f6635b6b1264296636d00c1c5a4088f29484a88cbf4ce5fc3dc101ea6bc384f7662d3259e94c96912590c905becd2e1e4f47ccc70cd7e337287677f009e46cbbae9d0c392afb6ba7af61354e62992197eb068d9928d283080a8bd4b59cde0c98284a3bee3912124ec1eef9b69c15c78e14fb6e54419ce8d2705d46fb05b9a4d52e2c2c842b50e7c284214e177f4868c6746d05f529a7f8016f9bbd1f0358ab9d8749ecd046b7279b284e3ca23a47652b2059275bd35d57dacac1ce1eb47b2b02e56d84f0ba8f96106645dde7cd6b131e3873c24c24c0e20c4a77ade66c308b0f3cf1d71b3b6a133d7042614fa03d9f61c94e1611f64711e4b5057ef6e61f325f42df660366e9ec50d566267e654bd60c74a08554a4da192a71f4a2e0ef82be419724830e4135d0bde94c1339e80a7300c15674f70f9dc660611b15b9e022f2ebb619980e3e648581fa21575a712d4a051826d969a6434c4a23d19f71cc2defa086e67294218d696d5b7ae63cb76751c26bfa2d7f9ea7121affddf9ddda8505588d3e6fbc65f94523986db7ec4ee73cbed0145ca96e6c1afef4874f7492a17004c7134280952f0d39b6522ed231e2422ac1754690b8c740a12562d1757583e3d65863b9e18556ee1d5242c6bf24823252fae93d0b19a2989e5e3e13984c1a6a43457ec828ae36ec42f26c9d5e4e03b7245980919d91efccff77db835eed57ac221e1844f0d11b2fee67955dc6bb00c4f6fd27442c57f8d95513e0dbf199cab25b8276419fd13cf1451222074683ca363bd616d20f2361bba3bc635778ac7088d72d569adb75ec44d83cef9e9935b358f260130dc5b7b4275aac001a55cca8f66b24c3a2fd8f37e8203dfdcf33b03fdc1eea0a745731d2cee79d95d9a32826716091b08ac67bc8ee4bdddcf90a53b2eafe89a6dccfd91027162539a31cec7c854bb34e1c6e8a569805cfbc1f6fbe459cb4368a603e8459094f677f1b64789396052f8fcf964e0981e749e154a129af93b0e0dbbd83d08e0020dff599839bc52d03e720f999350ec5655caffc7ce40d1c960db5d5a03e556a1e41d21d6c9dd764b4d9bd76822220078d4f6f9f3f2b9aec0f8f72b6c76664fc1d049936312947d34c87014d95c7a439f585d5dcfce5c446cf446003cf3d08b1214acaf9b296f0319d62479d688f03a20ea3450aa9ed9f1951e791525d0095c48911d7ba0be3786afe75ef8e54fde350ec66aa55bb90bfb73be79ab171f246b03c4168a66a637458a3d9a07ec97700ff8d54c9c35b261d1751da2eb84fcd54cda106d96a1d474ea1baf8619ee7f424d380dd373f0a42af3350ba935acecefa6d87fa0c642921ba800ec4ae2f42ffdc378b8bf159518b041109068d3696a4c89454e988878eecd0ea92e35adb2ffaf4f415a6d83be3b6700a86d0c980fd5ec2b73b13e8b35858d2356b827635f2d5e311a44e503fe90ff0e9394cbbe9ed8dc7c848d0db1fbbf421758cb5694b2e0c6e91b1e3de0ad120ae69d0b60245ef660b4091338e725ea60a52b23b3ae6ce40ed8c3ae8e975e1f3c4715385a00f442ce6b2c0ee9fadb2587038df49294dcb9f05fe429a32d7be729400d29840004c27b3da6b09ee00054958c6d857437a6e8ad45c0724c708198f5a9b6e13c38a396f903367672020cc48d444c883ed6a70c02cfc77b3587e2a00592ac1ac5c2b5f6e7acf52a75c8a4d50cd3ad823511a6e62acbf3c3ac19c423707b97f98a111aa30e1bfd8af3ed886734c8fa8eff93472835e5609835751953e4b20474cb8502e0d43b6bfb8540bff60b8642ba47fb5f26cf69fd7f1526976dcfe73ae13d9ca6ba460d0283a2c6a9d5e7fb0eee6e8eff182bf264a697591d6dbb9548b73d3e22b03a855c971dc0a42e3068181e3186bb2269a6ff2a4ba614f0f2aa326cd9872c55759d5c9b0ae85ba8d889845084f8cb571daf088ff36bdf46e64be110e6d451e54232b136c498f18a58bb9f67360eb2ed673210c61141ec339fc51da49168b8938641fc62a7eeb68342e813cc64afe42d6cee061d6d6fa5c7964483294fe7be942fa28da501565d79143f54d73826b75eab91489cd991a609c08dd94fbed75867f443d737fdbf4b9bd19d40b49f733a894e1008c881568b69ee41a23ba1f0cc7ec11b81af588f4a2fa133311eb85c18a54af9e378b61761721f3c54463096ca9c7f8d2f1c3547c029fbc5e833e9ab8ada35c107b4811c1d3554c10a45bb253fa529af8b1675dcf3271da3cdd191bed3f4addd1608bb4bfd4b388832b887a70296224814548c3cc2ecedd82233ae8bdc1e45789981df8a1c48d0ffdf5fe150e694130b2fbde068b347abc1c0dc33600307f90d0924155404266bba96972eef52740341f1c328235a1794664f07d1f2a1ea4b8d0ac7a52da04626d7adf7dad02ee3e8f23e5e383a676c560f4ba2e73664b8f84b484e541c46d6325df33229d743a6f7b1d16f948b990fe876da450941a0f1ef92b1d9855ae524168b4c5e94c13f1d27514db55d9e467fd1c9e200a5cbae1e747ca35c9028c9aade95e47dd024addd426a77d66ba1c448acbbea06534fc30b8d029eb94006070cf57d282e459a4ba5ddc0c4b929030d7b13787cf91dbc042d2ed26aa57688091d28b2ae1f65b7c1c705b8897193eca73aef6cb342b7876b98686d2a60af12b4cc0c285cf5ab9fae96a3e48d37c4654481688fafcb00ce599f29d929d2b3506b7724860042b4f7ff3e866c1c946b01e8d531454536ccd2439025c1459cb914191e55242b66260fe02e31251408c7c585b87ec9390f94a323ed86985353f832240dc7f1ab239479d37445efe8eea411da633ee2167b91c50316365cc8aa213d3bb45dfa8709e46a56657f897d862ec0a1cf1bb11b8403765f7750ddaa4e82ac46724cd8627dfaf7462b6ed251713a1e5a20e71703d880d7c33c49c66932524ee53563c158d4313081469618c33dde76788dc835560ed645d8484a63a0caea50f5a9386c051c58279b2cd09d8daa48376d82949804bb523a955966f0990bfbca87f6b3cbbef3038f15c66426b64f3ce9c5bc45aa4b379d026e89d6c01a9b48ace679e39a647d9649b26408604ea08ee2f09995244ac0efdbd305eab8f44fa8bd5e467fafc2ecd58f3153c8d7883a5ed210657ddaf17a684633b525217de61c25e1867554d9d4dbb2c7dde0ff6aa575a26cfaf162a77ec352eb1fb92f5485ac3ceeed0d48009cc249815bcdc11f43c8b28a938ba69395de5b819c7c95b565fa8ea6c673e29eb7656f6701ff9e28e754446bea945d0f5ff9c821db69c8792a832698120147a812f4503a31bddb9b14d22df09cd44a67e0536dbb6418dde35f1cb7c4a2e22d437928c4a0a53f0cb509e513d1d036b058d30705a22a8d84bc573333d7fb5c334606fbe2f9f60a4d34884474cdeb0e475c0aa20526b952edc5748aaa854d03f85b382e91c6a551c0d41878fcfaf38799fc57512809ccfef94247ae5fffa51d8a03327443965a6054e15ab5bc5df85e6c346d8b9e2ccaf965e777bcdee89e3238493b7b039fb713b7fa9887066800213c563bf0ad0c057fcab7aca0c9706fdbc6980672feee9db4cda9b6ac75070d0671004b2806375a95c4569d5904481272e36bb751dd17be49d3d585ed6f12dfb8553df1eb7f1f8c94621c5ffa9d5a7b38cb1ff9e163d3a5db459f032020d7a0b3fb718e9959472d316fdf2636517c42068f9aa3d72dd74769be15b54173eaff097f36dfe39524f847b805aaeb8541347fc5740baf589a4ef5b360a0ffc18c0fb8e77ff5795a97bde1be4cfc451d96c085778035928c060a11e964b1c07fbd0997618508e4e47bd420318029a9e41784987363674db489cd73d9a7a1a052ebdb55fb3d0a1ac2f4ca0f5d4be305cc9b644b2196174fcdcbe8272b151b4348c0b71f0f5d1fd8a3cd9ae953aa84bac998a1423ce30f0c31b76af177e51793f3d074d05d90a53076ea1a01b7e85ee290e6aff7d6f42e958c8fa178a6f2d1510ee0441994725cffb4195b2c23d38466abcf399bf995f3494f5f501a560f28b23ea1aab47b0690b9cacd1d6142eccc11d61da12dd41f7d9eafe23a612eeac23827fcd5324cd9dfc320f82c08310075e714e5e1659069a637b2a2e359cef53fc263608cddc521196f4aa20b4eaae7a4fb68de251cc74c5f95d4fc3411610ef12b312b701109ea30d646d62972dc9f0243415f5596840d06895ec101e9c34986ef93bef221ea748ddd11dfdd7b4e4c9c1f5b74c3577362fba230a9d51066658692e968fe7eca337f35aff06372ec7f92930052ea1e7ec4f10af830112b12987357eceed78a0be418889834e5b080a314e921845c7ea1c529b5934aa91f1d10e33c77527e9b55057e4eb2fe03a9ccfa6e3a1b9049b8851537a93a0734462620fd3afa2d7e94e8d5313d9203f2581118130f0b131826b7d23595215a6ad426948ef6ae0c4bfd1047c4b0fc34a03915c672e2947f40518a65883efdb458c320faaa4f907b1ab786120aff2e6b8f24ce61dae903b4d34bda4d65bce09a096c10abda5bcb4d1285b4e970d8bf70b4f3977221a465ef664416df64824108017e1d1ac53ef7190003f97d51dccdea6d94bdaa868c2fa513fb9bfe24e2f7358989bc2d3fc081497bc4256ab348f12de36de3f78e12b9139b7ac07a2526c2fcbfdd653a42e2ee1fd710f9cd68cd8363747bf3f9a7fbf0374c902036d55678f500f637ac195c4038d85cd936851e60cb2fee2e59670e63f8add67fb15fe26ff1c734955c097d156c29a161db774dffb9e0dea639efcb7c36603a1f8a5fcef3a21a1ff238c236b8e3f1459560ebe2d23e58973cc99de7788627b8d73282ea358074ca29bd0375246ea4f8d584863d3c748d2ef0961fe3bc511af19ee66b6540d8a8819083339363e5174063dd3fa2fab9983a993dad2250c3ccbb669035fc56fc257822b925c7d0288d1603422579614c0a879e500ac3e07d3729b84be9f514f962ab9ee1352d4a791b3284e7bd6a99d782a915b17f5df7c01cd7c8c115543fd0987e024e2276599751c0254eefbb5fcb46e402054666c9574c22e8f35edff64382809c49dfaa34db68fcdd8a30b9a5dde05cbe9f4b595d25e10ab6241c91aeb5c9f92b6a7c99a32e7fc32fdb4fb7f7264910ff4e7f1717f11c7e8a10a72ed387055e010e7ed2589890d464a3c9fe8a55a1a0d3e2882ddcd1d1dfa83522f2586add345da7f1ebf8971f5bc960f9e296a615afb064a41c60bccfcf8ec41c7041ad5f3cf2cc7e12b8f3ba4eea40d23007cb43c45649e6a683a3c69409622f61fb4c2683977134eb75c808ca24c9201bd9a71a9d1ed7fd714a8c845f11f0ead27ad0bc80a1bea75bd46bbc2e349c1216fdb9b4764c8571e751c562697be66c2722925628b91621c417222b540625eea2292cb23191e13b1a18e900d1c0fbd28471a3f71af1aee3164851ce4a9de464c3df4efaf92cd349097941ee27e52dbe41bf28d035dfeb5499c7222e52f16fea280268c5fddbc824c27c04d815713432bb86969cbaa74ba3bed6c9c09198550b540124c06f4d287df4bbd8c3de64c5afb101f9c3b7abd560aaecc5c23349c7f6a6d70a5f15267d79241688c1c6d8eef57c84f97463ab3c9bc78bfe6d417d6ff65663a1e1efb1291d7f36c118ad73f0e8eb4904cc80ba5811833b7538c6dc96afc7fffecf79889ab8aa1454c024c9b007b2879827f5a52a3aaf3bc7100adfefb06c93d39c51cd3ba5c543c26aaa685c91138ad5490e102295a8274a5c8b8196c447bd2c1767f42c168883820efca9757695ca989835df40578a506359cbca487b6d0258c07cd37e5aed595c9a6281656308ff5fc8afa363bb48f5e0001b045fc1fe45e00b6dd61b2ae9826e63eb5b06479a26347857b3f454ce0dd384506d6687893b52e3055444b537ddff517aff22eb1f4ab2d86a899830ac1fbec3522ba54669c3c5637f2681512208c6b5ba982f209293753e0905187a6182c9aee0f99d37bfb9d18987962bee14c3e0f7848164ad0b3f2f7e504a3eadc72f3248efe8415a50f1b226906ee701409b2469d0c5fb722905ad005654607fa75e78d078ffaff96b9be9b3efe121143b9dc7b0194270f942fa7e1ed040ea1959510e5ee0b9720212da6be88aec78b9ef6cc245d5a0021fc387ba52f6954aac9aeed688d79db2ae2a02a82e2c3e5bb7fc2cb9ef67fe948349ba503833ac00cfda3859b8ccfc1c2920d84b6c0f21c6338f8cebdb529581b5fd660a000942726a7ff337cf2e6f01ab35d4b50fb340a8af1e03baac97af08d2ff6bc9ce455db95ba96be42a72404faca24cdc4efa3986be27811e9b0eb7fbaae647d08c595d4bf67c2675395bcb6b1584381a5d282febf4bc15f2dfa4a746fa3558f61658076836fd07ea616221b2ada9f62e94b7ee135a17252f6747395e00b05d995cce57958d0a7d49e18832e1c78b59a54b492a9430bd8b9a8f23a6f336897660b457093aafe599e6cca287ada9480ec96e5f7b63f047267000ea43ee2add8832874ecd6713e03b07c5373ff4dfae82330661faad81e0fd8252264274da512d69eb5f61182fa9adb3d5f5dc38b386f26db7d9d136b0d32fee06ece2abd88b08f035c803f46320aa73054a38217cb4951b9e4b9f7c2337e4f4db16c5de335c58b257cd46434dfca976fa483105085d39f653d0d73a6a8040ad916abf872f4024a0b66f0a7c495b6164a91959ee1e38ee050af1af7d83b4b27adfeb6b073e172e1425adeb56434207bac45da12ccc22ccd2b1f7d1739df5a64cdf9a7e7d588318542721ff3ac2671c50e6460fd458521a6d0df324f5b66de1b51fd5ac7bfc47c850bac3d57b1a33a4fd0e8ab31db5194485cc1f08834b18718dd4fd3e74cdf3a6f03433a09e7cf14a03183de21f32bdb000d93ad2c0b7760d89fe474dbf0d3201bb477f62377e79743ff33c38bcb448fb3f82c56227d260945b109a3e52753e0592bce09ab1b2afeb4c8a3ab635e318e1079347f7c1af44261970a8355b6025d5497734833b6f138591614f69e30d3353354de2418fe5f71d05e78eed437c9f879b7de5663cfc3ed639c223b5d04388ea2ff4d00d6ec32f365bd1a9af5a7544aab30e63c36987c2ceb0095c869bc15e6a5c416e2c0920485cecf2d652ba12a91c99633b4c3cd85c454ba2d3208083018315912ca92c61086551b075f746f7d60431bea99396bb39725612075a18f9b78536cd743fcfab595d26f4fba7eb6671007a1768cdfdffdd0395cf790aa8d64709ecb379fe6d4a5e2f3ed1ff89be8b80401a73c8c3366e65f8833c3cd9a94456a30d73d8bc722f3be1ef977317ca34a8ea16b945b96e7ee7f84dbfd2c670413ffc32961d6767d01b25480600e4f44f59fdc4aad85d382afa6ebc1f59b0bf9a53210cccbf07d74409b09b150213f0d93fda9049a13e5c35286dc1b557a1130d4f367fb71dee36da43d4dabfd030fd97911fd0f25693f4f81a60b2eb21a90483f15361944a757d9efa04188a6790d2e67fab6193f018738664c76cef1c1284cfc3f52091efbed7df27c188bc96b811818f83ebdeb1e071bb45be27614530bb29ff2077e4113bec2fc9678783aa79c3773a74327777d1ea2c4e8af26b1614be737e0992bb1d7071c26f9181fa6ab800eb62ed671a99c15cb9398d41f299970dd4351828622cfd4bd91f72d5583276a39e7e53f3b591a4485add33bcbd558ab1df1fb0e5b83f0eb5933a83b5160c4ec2ce6005f98e13fd5ae921ad7ba9945ff0f3cc982051f925c0d776569b128fe553635def115bbdfbc0e063e15cbe2e801dc230128c66117f7a1b9aa81381ed6b0b8a075b6303069e65eea132b24e24db00a10663a5ff2194193ef21f9b04fad2a692ecd2414e474235717af3ed1ceef9124c864e6201387a13f9f98dd4f787cd9f0ce67c92908bec4609bdc7384573e43e0f77c5a5a868daf835c9936607cc74cfc3614f44c517cda8da748c6b047e5c913ceb6aa6ddfd48bd8d0da631f0714e5aa412026ced4f58fe1c6c7dad62fd3e602a95662c8194a495aff7621700b61163e27f0e257720464a77188f4e33a8e9321358d934a74efb1e92e149a83f4081771c562598223a0624cb8b27cd62191fbf78c5aa0e0e725766fe7e7947b392779c72cd8c93647e4c742052c9b96aefd52cb1b686b8303017e9a8b4d7c9bd6f6085fbd9b81bd2d7864504ec240ecd14f83b0980cdd6f87ef7227eb918855efe823398dc33f187030ce71fa9368402803b41976f48e44524c7536ed14ffaab5e5c07d54e2c2ca2954767e52c6680ecd71ed45d8ac8967f1eb63dffa0193dc434868777a3f50c682209f8f80521d31f5b5157c8154ae76b612d6d99b545dd1c91c4fc2a9c235ef1d30a6e344982845ca8103f55e4b937a6018be9c063c7d52e7dc6967e327b59d8cbb9711962c081fa8af9fadbbb02401816628bd13f8d699659f414c3b3a09d842042853f00944b91a45a5addc3d4aabfcdf45e5e863a823b8591b8e7b41d80731ce6e692d41bbe8b931405a51800805fcf72f79279b70df5c292a6a5edd3d89813a875b1de4dd25c662bfb671f90e18efb6d05d19009b2680a6c6e513054121d064d3ad9ce0bdf3c0167e7be9d6fb35f49fcb6b32ef63a1ce5d79609a176f0b93ab8accec0213c7fd887adf527b09f2ba9c7f5664a90a311f965d5b82bc0dc0d6004b83e8bdec0b3480a664fe6320c8b5e25207b54ee49f471a41ff5474f2e0927e84d735848e04ee072b07af622351d61bc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">就不给你看。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瞎写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2022/12/01/test/"/>
      <url>/2022/12/01/test/</url>
      
        <content type="html"><![CDATA[<h1 id="芜湖"><a href="#芜湖" class="headerlink" title="芜湖"></a>芜湖</h1><p>Hello,World !!!</p><ul><li>列表康康</li><li>sdasjdkas</li><li>sajdkljas</li></ul><ol><li>sajdhasuhd</li><li>shajdhas</li><li>shdjhasdh</li><li>nashdjh</li></ol><p>20240721</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> First step </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算 补码 反码</title>
      <link href="/2022/10/05/%E4%BD%8D%E8%BF%90%E7%AE%97-%E8%A1%A5%E7%A0%81-%E5%8F%8D%E7%A0%81/"/>
      <url>/2022/10/05/%E4%BD%8D%E8%BF%90%E7%AE%97-%E8%A1%A5%E7%A0%81-%E5%8F%8D%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算-补码-反码"><a href="#位运算-补码-反码" class="headerlink" title="位运算 补码 反码"></a>位运算 补码 反码</h1><p>很多初学者经常搞不懂<strong>补码反码原码</strong>这些东西，今天我就在这里好好理一下。</p><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>先来讲讲基本的与或等运算，会的可以直接跳过</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">与 AND</th><th style="text-align:center">或 OR</th><th style="text-align:center">异或 XOR</th><th style="text-align:center">非 NOT</th></tr></thead><tbody><tr><td style="text-align:center">1,1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">1,0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0,0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">有0则为0</td><td style="text-align:center">有1则为1</td><td style="text-align:center">异常的或，在都为1的时候为0</td><td style="text-align:center">取反</td></tr></tbody></table></div><p>容易看出，<strong>与，或，异或</strong>是二元运算（即有两个操作数，如加减乘除也是二元运算），且满足交换律。而非是一元运算。当然也可以有多位一起参加运算，如10 ^ 11 = 01，各位运算是独立的  </p><p>另外，与，或，异或也满足结合律：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a &amp; b) &amp; c == a &amp; (b &amp; c)</span><br><span class="line">(a | b) | c == a | (a | c)</span><br><span class="line">(a ^ b) ^ c == a ^ (b ^ c) </span><br></pre></td></tr></table></figure><p>其中&amp; ，|，^ 在C语言中分别表示与，或，异或运算，现在来证明一下：</p><p>与：只要位上有1，结果必是1<br>或：只要位上有0，结果必是0<br>异或：位上1的个数为奇数，结果就是1,反之为0</p><hr><h2 id="原码，反码"><a href="#原码，反码" class="headerlink" title="原码，反码"></a>原码，反码</h2><p>现在来讲讲正题。首先我们要知道<strong>补码和反码是两种储存数据的方式</strong></p><p>大家都知道计算机里存储的是二进制数，如果我们用八个位表示一个整数，<br>如<strong>2 = (00000010)</strong>，其中00000010就叫做2的<strong>原码</strong>。</p><p>这样我们就可以用八位表示0～255的任意整数了。但是我们如何表示负数呢。我们就想出了反码这种东西。要理解这个还得了解一下计算机如何执行加法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2+1 = (00000010) + (00000001) = (00000011) = 3</span><br><span class="line">2+2 = (00000010) + (00000010) = (00000100) = 4</span><br><span class="line">2+3 = (00000010) + (00000011) = (00000101) = 5</span><br></pre></td></tr></table></figure><p>可以看出就是两个加数各位异或，再加个与运算判断是否进位。（可以用这个原理在MC用红石搭个简单的加法器）。</p><p><strong>所以我们如果要表示负数</strong>（最关键的问题），可以用 a + (-a) = 0来定义表示方法。我们不妨定义(11111111)为-0（也就是0）这样我们我们就可以把一个数各位取反来表示她的相反数。如(~表示取反)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2 = (0000 0010)</span><br><span class="line">~2 = (1111 1101) = -2 //这些操作在实际机子上不成立，因为我们现在是以补码方式存储数据</span><br><span class="line">2 + -2 = (1111 1111) = 0</span><br><span class="line">---</span><br><span class="line">0 = (0000 0000)</span><br><span class="line">~0 = (1111 1111) = -2</span><br><span class="line">0 + -0 = (1111 1111) = 0</span><br><span class="line">---</span><br><span class="line">127 = (0111 1111)</span><br><span class="line">~127 = (1000 0000) = -127</span><br><span class="line">127 + -127 = 0</span><br></pre></td></tr></table></figure><p>这就是<strong>反码</strong>,指的不仅是按位取反，还指这种存储数据的方式</p><p>由此可见，(1000 0000)不能再像原来那样表示128了，因为他现在表示-127，以及128以上数（最高位为1）的表示方法同样被抢走了，所以我们就不表示这些数，那现在我们用八位表示的整数范围便变成了[-127,127]</p><p>我们还可以知道，最高位是0的数现在都是正数，而正数取反后得到负数，所以负数的最高位是1（不严谨的讨论，-0看作负数，0看作正数^_^）所以我们现在把最高位叫做<strong>符号位</strong></p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>可是我们知道我们现在都是以补码方式存储数据，补码又是什么，相对于反码又有什么优势呢</p><p>补码也叫做<strong>二补数</strong>，而刚刚介绍的反码叫做<strong>一补数</strong>，这也可以看出补码是比反码先进一点。</p><p>仔细看看我们刚刚的反码，我们用了(0000 0000)和(1111 1111)两种方式表示0，这使0的编码不唯一了，很多情况下我们需要特殊判断，导致效率低下（特别是电路设计中）。所以我们用补码解决了这个问题。</p><p>补码和反码的区别就在于负数的表示。回到最初的问题，我们需要表示负数，但现在我们不能再用(1111 1111)表示0了，要坚持一个0原则(0000 0000)，可我们的 a + (-a) = 0还是要成立的，所以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 = (0000 0010)</span><br><span class="line">2 + -2 = 0 = (0000 0000)</span><br><span class="line">-2 = (1111 1110)</span><br></pre></td></tr></table></figure><p>我们就有了另一种数据存储方式，(1111 1110)就是-2的补码。现在我们来研究一下她的性质</p><p>我们容易得到：（1溢出到最高位之外了，我们不要了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1111 1111) + (0000 0001) = (0000 0000)</span><br><span class="line">(0000 0001) = 1</span><br></pre></td></tr></table></figure><p>可得(1111 1111)表示-1</p><p>还有：（再说一次～表示取反）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2 = (0000 0010)</span><br><span class="line">～2 = （1111 1101）</span><br><span class="line">2 + ～2 = (1111 1111) = -1</span><br><span class="line">2 + ～2 + 1 = 0</span><br><span class="line">---</span><br><span class="line">a + ~a = (1111 1111) = -1</span><br><span class="line">a + ~a + 1 = 0</span><br></pre></td></tr></table></figure><p><strong>所以我们得到(~a+1)就是a的补码</strong>，也就是我们常说的补码等于反码加一</p><p>这样子我们就解决了0的唯一性，现在我们有：（可以去和上面的反码方式对比一下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 = (0000 0000)</span><br><span class="line">-0 = ~0 + 1 = (1111 1111) + 1 = (0000 0000)</span><br><span class="line">---</span><br><span class="line">127 = (0111 1111)</span><br><span class="line">-127 = ~127 + 1 = (1000 0000) + 1 = (1000 0001)</span><br></pre></td></tr></table></figure><p>那我们现在就可以比反码多表示一位了，可以看出(1000 0000)这一种表示方法没有被抢走，所以我们就可以用(1000 0000)表示-128。所以我们能表示的整数范围现在就是[-128,127]。</p><p>这就是补码和反码两种存储数据方式。</p><hr><p>我们可以用程序实验一下计算机里是如何用补码存储数据的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>;a &lt;= <span class="number">10</span>;++a)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,a,~a,~a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0 -1 0</span><br><span class="line">1 -2 -1</span><br><span class="line">2 -3 -2</span><br><span class="line">3 -4 -3</span><br><span class="line">4 -5 -4</span><br><span class="line">5 -6 -5</span><br><span class="line">6 -7 -6</span><br><span class="line">7 -8 -7</span><br><span class="line">8 -9 -8</span><br><span class="line">9 -10 -9</span><br><span class="line">10 -11 -10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Ubuntu简单软件管理命令</title>
      <link href="/2022/06/05/linux-ubuntu%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/06/05/linux-ubuntu%E7%AE%80%E5%8D%95%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu-简单软件管理命令"><a href="#ubuntu-简单软件管理命令" class="headerlink" title="ubuntu 简单软件管理命令"></a>ubuntu 简单软件管理命令</h1><p>查看已安装软件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l </span><br></pre></td></tr></table></figure></p><p>关键词(“<em>*</em>“)查找软件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l|grep &quot;***&quot;</span><br></pre></td></tr></table></figure></p><p>卸载软件:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt --purge remove &quot;***&quot;  </span><br><span class="line">#这里的&quot;***&quot;是要在dpkg里的名字，可以通过关键字查找得到</span><br></pre></td></tr></table></figure></p><p>安装软件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i &quot;***.deb&quot;</span><br></pre></td></tr></table></figure></p><p>压缩文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zip (-r) filename dirname</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把<span class="built_in">dirname</span>压缩为filename.zip</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-r递归，压缩子目录，一般都要加</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同windows系统兼容好</span></span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rar a filename.rar dirname</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把<span class="built_in">dirname</span>压缩为filename.rar</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">自动递归</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果提示未找到命令，执行</span></span><br><span class="line">sudo apt install rar</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf filename.tar dirname</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把<span class="built_in">dirname</span>压缩为filename.tar , 注意tar不能省</span></span><br><span class="line">tar -zcvf filename.tar.gz dirname</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把<span class="built_in">dirname</span>压缩为filename.tar.gz , tar.gz不能省,（只是参数多了个-z）</span></span><br><span class="line">tar -jcvf filename.tar.bz2 dirname</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压成tar.bz2,参数为-j,其他同上</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-v --verbose为显示过程</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-f --file 不知道能干吗，反正我试过了不能不加</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">linux中最常用 快用快用</span></span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip filename</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把filename压缩为filename.gzip,只能鸭文件不能鸭目录（或许可以，但我不会）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以用tar打包后压缩，也可以直接用tar的-z参数做到，bzip2同</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所以不常用，可以用tar替代</span></span><br></pre></td></tr></table></figure></p><p>解压文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip filename.zip</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar x filename.rar</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf filename.tar</span><br><span class="line">tar -zxvf fliename.tar.gz</span><br><span class="line">tar -jxvf filename.tar.bz2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把压缩的-c换成-x</span></span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gunzip filename.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不常用，可用tar替代</span></span><br></pre></td></tr></table></figure></p><p>先写这么多了，要去上学了。还有些压缩命令如gzip2等没写道，但这可以用tar的-j参数实现，记住这些一般就够用了，还有dpkg apt的细节我还不会，毕竟</p><blockquote><p>来路方长</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux使用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法大纲</title>
      <link href="/2022/05/29/algo-2022-12-02-%E7%AE%97%E6%B3%95%E5%A4%A7%E7%BA%B2/"/>
      <url>/2022/05/29/algo-2022-12-02-%E7%AE%97%E6%B3%95%E5%A4%A7%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="算法大纲"><a href="#算法大纲" class="headerlink" title="算法大纲"></a>算法大纲</h1><h2 id="for-oier"><a href="#for-oier" class="headerlink" title="for oier"></a><em>for oier</em></h2><p><img src="img.png" alt="算法与数据结构"><p></p><p>简单聊一聊算法学习。<p></p><p>整个的学习主要分成算法与数据结构两大块。我相信很多人也听过<strong>程序 = 算法+数据结构</strong>这句话，那我们就来分别讲讲这两个东西。<p></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>这里我就不像教科书里那样赘述算法的定义性质什么的了。就直截了当的开始讲讲各个算法的特点，以及竞赛解题的思路<p></p><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>这或许不太能算的上一种算法，但这确实对于解题至关重要。对于一题算法题要是连暴力解法都想不出来，那这题也差不多拿不到了（裸题除外）。而其他算法（以及数据结构）也只是对代码进行重构优化<br><br><strong>其他算法决定你能拿几分，暴力决定你能不能拿分</strong><br><br>而这种算法之取决于你的思路，一些题目对智力要求不低，说他是最简单而又最难的算法不无道理。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>BFS，DFS，A<em>，IDDFS，IDA</em>等等等等，是一条蛮重要的路线，而且和图论密切相关，是必须掌握的。</p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>和暴力差不多，是人类最朴素的思想的产物。是一种重要的算法思想，很多题目或多或少都有他的身影，注意他是一种思想，而不想搜索一样是一种明确的算法。</p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>和贪心一样，也是一种重要的算法思想，log级别的优化经常用到</p><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p><strong>动态规划</strong>，简直太简直了（）<br><br>难题必备，具体思想我现在也没搞懂。</p><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>慢慢学吧</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>不会很难(吧)</p><h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><p>不会，以后再说。<p></p><p>既然是大纲，就简单写一写了，我也没有时间和实力展开写，<strong>以后再说</strong>吧</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>也是很重要的一块，特别是高级数据结构，题目难度不亚于DP。<p></p><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><p>大部分已经用STL实现，<strong>NOIP = C语言+STL</strong>，STL要熟练掌握<br><br>数据结构和算法也密不可分，比如BFS就要借用队列来实现。</p><h3 id="高级数据结构"><a href="#高级数据结构" class="headerlink" title="高级数据结构"></a>高级数据结构</h3><p>树，树，树还是树。幸好的是STL的map已经实现了红黑树，这些奇怪的数也不用太纠结了，但线段树和树状数组这些东西，优化代码（题目数据很大）的时候还是需要的。<p></p><p>就先写这么多吧。<p></p><p>PS:最后提几句，oier真的挺不容易的，五大学科竞赛就信息学和高中学习相关最小。两头都得顾。别人铸剑三年，锋芒一朝。而我们要铸两把剑。特别是我这种小城市的学生，竞赛资源小，也不知道能走多远。只是不想放弃而已。等着吧，说不定就成了呢。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无题</title>
      <link href="/2022/05/29/untitled/"/>
      <url>/2022/05/29/untitled/</url>
      
        <content type="html"><![CDATA[<h1 id="随便写写"><a href="#随便写写" class="headerlink" title="随便写写"></a>随便写写</h1><p>_2022 5 29 1:17_<br><br>忙了一个晚上，什么也没干成，至少开始动笔了，就写写吧。<p></p><p>语法我也忘了差不多了，今晚我什么都不想讲了，就还是测试一下，把环境配好去学校不至于太尴尬。<br><br>测试数学$\alpha$<p></p><p>$\frac {a}{b}$<p></p><p>看看插件,感觉也没什么是必要的。这部机子的配置，一切还是轻装上阵为妙。<p>困了今天先到这里，哦不是早上先到这里，我看看能不能发博客。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八数码问题</title>
      <link href="/2022/04/03/algo-Eight/"/>
      <url>/2022/04/03/algo-Eight/</url>
      
        <content type="html"><![CDATA[<h1 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h1><p><strong>题目地址</strong>:</p><p><a href="https://www.acwing.com/problem/content/181/">Acwing</a></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1043">HDU</a></p><blockquote><p>在一个 3×3 的网格中，1∼8 这 8 个数字和一个 <code>X</code> 恰好不重不漏地分布在这 3×3 的网格中<br>在游戏过程中，可以把 <code>X</code> 与其上、下、左、右四个方向之一的数字交换（如果存在）。<br>我们的目的是通过交换，使得网格变为正确排列<br></p><p>把 <code>X</code> 与上下左右方向数字交换的行动记录为 <code>u</code>、<code>d</code>、<code>l</code>、<code>r</code>。<br>现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列</p></blockquote><p>我花了好几个晚上才完整的写了出来，毕竟还是新手，但独立写出来之后还有一点成就感(当然有参考)。下面就来小小提提我的思路吧。</p><blockquote><p>bfs不仅可以搜索路径，还可以搜索状态。</p></blockquote><p>这是我从黑书上看到的一句话，从后几个晚上便开始了我的不归路。</p><p>所以我也用黑书上的思路，<strong>bfs+cantor</strong>解决这道题</p><p>这题要寻找最短路径，所以bfs更适合</p><h2 id="1-广度优先搜索-BFS"><a href="#1-广度优先搜索-BFS" class="headerlink" title="1. 广度优先搜索 (BFS)"></a>1. 广度优先搜索 (BFS)</h2><p>这个思路很好理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始状态入队</span><br><span class="line">while(队列不为空)</span><br><span class="line">取出队首</span><br><span class="line">if(找到目标)</span><br><span class="line">返回答案</span><br><span class="line">else</span><br><span class="line">相邻状态入队</span><br></pre></td></tr></table></figure><p>伪代码非常清晰，现在我们把<strong>文字展开成代码实现</strong>得到。</p><p>首先我们联系一下问题</p><blockquote><p>输入占一行，将 3×3 的初始网格描绘出来。</p><p>例如，如果初始网格如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">x 4 6 </span><br><span class="line">7 5 8 </span><br></pre></td></tr></table></figure><p>则输入为：<code>1 2 3 x 4 6 7 5 8</code></p><p>输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。<br>如果答案不唯一，输出任意一种合法方案即可。<br>如果不存在解决方案，则输出 <code>unsolvable</code>。</p></blockquote><p>我们可以用多种方式存储状态，我这里选择的一维数组。<br>因为输出行动记录，我的思路就是用一个<strong>结构体</strong>存储<strong>数组</strong>和<strong>上次到这次的行动</strong>，还有<strong>上次状态的地址</strong>。</p><p>语言描述有点难懂，现在来看看代码实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">state</span>&#123;</span><br><span class="line"><span class="type">int</span> num[<span class="number">9</span>];<span class="comment">//数组</span></span><br><span class="line"><span class="type">char</span> ch;<span class="comment">//上次到这次的行动</span></span><br><span class="line"><span class="type">int</span> re;<span class="comment">//上次状态的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里说到说到上次状态的地址，这是一个<strong>整数</strong>而<strong>不是一个指针</strong>。<br>这是因为我们使用<strong>数组</strong>模拟bfs中的<strong>队列</strong>，这个<strong>整数</strong>是<strong>数组下标</strong>,<br>搜索的元素出队后，<strong>不会删除</strong>，而是数组头指针和尾指针的移动。所以我们可以这样记录地址</p><p>更详细的可以学习下队列相关知识。</p><p>实现一下，看不懂没关系，稍后会解释(看起来代码很长，其实很多重复的地方，读者可以试着优化)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">state <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//初始状态入队，把初始状态的上状态地址设为-1，以便区别与普通状态</span></span></span><br><span class="line"><span class="function">begin.re </span>= <span class="number">-1</span>;</span><br><span class="line">q[++tt] = begin;</span><br><span class="line"><span class="keyword">while</span>(tt &gt;= hh)&#123;</span><br><span class="line"><span class="comment">//是否找到，如果队首的九个数都和目标相同，则为找到。也可用memcmp等函数</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)</span><br><span class="line"><span class="keyword">if</span>(q[hh].num[i] == aim[i])</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">9</span>) <span class="keyword">return</span> q[hh];</span><br><span class="line">        <span class="comment">//寻找0的位置，我们在输入的时候把x换成0，这样子,方便数组存储</span></span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line"><span class="keyword">for</span>(z = <span class="number">0</span>;z &lt; <span class="number">9</span>;++z)</span><br><span class="line"><span class="keyword">if</span>(q[hh].num[z] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//判断相邻状态</span></span><br><span class="line"><span class="keyword">if</span>((z+<span class="number">1</span>)%<span class="number">3</span>)&#123;<span class="comment">//是否能向左，依题意得2 5 8这三个位置不能向左 </span></span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z+<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//是否查找过状态，vis定义为  如果找过则返回false，反则true</span></span><br><span class="line">            <span class="comment">//具体代码实现就不给了，因为后面后用一个更nb的函数代替</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">vis</span>(tmp.num))</span><br><span class="line">                q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z % <span class="number">3</span>)&#123;<span class="comment">//同上</span></span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">vis</span>(tmp.num)) q[++tt] = tmp;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z &gt; <span class="number">2</span>)&#123;<span class="comment">//ts</span></span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z<span class="number">-3</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">vis</span>(tmp.num)) q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z &lt; <span class="number">6</span>)&#123;<span class="comment">//t</span></span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z+<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">vis</span>(tmp.num)) q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">++hh;<span class="comment">//弹出队首，因为我们前面不是取出队首，而是直接用队首，所以在此弹出队首</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> begin;<span class="comment">//如果没有找到，返回begin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>: 因为我们用一维数组存储当前格子的状态，也就是（已经把x换成0）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 0</span><br></pre></td></tr></table></figure><p>存为 <code>1 2 3 4 5 6 7 8 0</code>     对应的a[0] = 1,a[1] = 2,a[3] = 2    也就是3对应的<strong>位置数组下标</strong>为2   </p><p>由此可知，当0的<strong>位置数组下标</strong>为2，5，8是，不能往左走<br>同理  0，1，2时,不能往上    0，3，6不右    6，7，8不下<br>随后用if条件判断即可。</p><p>而行走我们用了swap函数，交换0(即x)的位置数组下标和目标位置的下标，完成一次行走</p><p>最后把<strong>上次到这次的行动</strong>和<strong>上次位置地址</strong>存储到tmp上，如果符合条件就入队。</p><h2 id="康托展开-Cantor-Expansion"><a href="#康托展开-Cantor-Expansion" class="headerlink" title="康托展开 (Cantor Expansion)"></a>康托展开 (Cantor Expansion)</h2><p>代码主体部分已经基本完成，但还有很多问题，比如判重函数 _vis()_  还没有实现，如果没有判重，程序会产生很多无效操作，复杂度大大增加，但如果使用暴力的方法判重，每次把新状态和9! = 362880 个状态对比，可能有9!*9!次检查，必<strong>TLE</strong></p><p>所以我们用到了这种数学方法<strong>“康托展开”</strong>判重</p><blockquote><p>康托展开是一种特殊的哈希函数</p></blockquote><p>实际上，康托展开听起来很高大上，其实就是<strong>把几个数的排列映射到值上</strong>，每个值对应一种排列，如4个数的全排列可以用4! = 24个值表示，见下表</p><div class="table-container"><table><thead><tr><th>状态</th><th>Cantor</th></tr></thead><tbody><tr><td>0123</td><td>0</td></tr><tr><td>0132</td><td>1</td></tr><tr><td>0213</td><td>2</td></tr><tr><td>0231</td><td>3</td></tr><tr><td>……</td><td>……</td></tr><tr><td>3210</td><td>23</td></tr></tbody></table></div><p>那如何完成从状态到值的转换呢，当然是有公式滴</p><script type="math/tex; mode=display">X = a_n(n-1)! + a_{n-1}(n-2)!+...+a_2\times1! + a_1 \times 0!</script><p>其中， $a_i$ 表示原数的第i位在当前为出现的原数中排第几个(从0开始数的)<br><strong>乱七八糟</strong>，对吧</p><p>其实这东西真不难，看着唬人而已，我们来展开几个数试试。</p><p><strong>0    2    3    1</strong><br>第4位为0，0排第<strong>0</strong>个，0个数中<strong>没有数</strong>出现过，$a_4$ = 0 - 0 = 0;<br>第3位为2，2排第<strong>2</strong>个，2个数中<strong>1</strong>个0出现过，$a_3$ = 2 - 1 = 2<br>第2位为3，3排第<strong>3</strong>个，3个数中<strong>2</strong>个数(0,2)出现过，$a_2$ = 3 - 2 = 1<br>第1位为1，1排第<strong>1</strong>个，1个数中<strong>1</strong>个0出现过，$a_1$ = 1 - 1 = 0<br>所以<br>$X = 0\times3! + 1\times2! + 1\times1! + 0\times0! = 3$</p><p><strong>1    0    3    2</strong> <br>第4位为1，1排第<strong>1</strong>个，1个数中<strong>没有数</strong>出现过，$a_4$ = 1 - 0 = 1;<br>第3位为0，0排第<strong>0</strong>个，0个数中<strong>没有数</strong>出现过，$a_3$ = 0 - 0 = 0<br>第2位为3，3排第<strong>3</strong>个，3个数中<strong>2</strong>个数(0,1)出现过，$a_2$ = 3 - 2 = 1<br>第3位为2，2排第<strong>2</strong>个，2个数中<strong>2</strong>个数(0,1)出现过，$a_1$ = 2 - 2 = 0<br>所以<br>$X = 1\times3! + 0\times2! + 1\times1! + 0\times0! = 7$</p><p>作了这些练习，有没有一种编程的欲望？下面给出代码实现(我自己写的，当然还有优化空间)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> org[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;<span class="comment">//原数</span></span><br><span class="line"><span class="type">int</span> factory[<span class="number">11</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;<span class="comment">//阶乘打表</span></span><br><span class="line"><span class="comment">//bool basket[10]之前定义在外面,debug找了好久才出错,数组很容易犯这种错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看有几个数出现过</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> * basket)</span></span>&#123;<span class="comment">//因为basket为cantor()的成员变量,所以传进来</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; x;++i)</span><br><span class="line"><span class="keyword">if</span>(basket[i])</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cantor</span><span class="params">(<span class="type">int</span> * a)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> basket[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//查看有什么数出现过,记得定义为成员变量,并初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)&#123;</span><br><span class="line">x += (a[i] - <span class="built_in">g</span>(a[i],basket)) * factory[<span class="number">8</span>-i];</span><br><span class="line">basket[a[i]] = <span class="literal">true</span>;<span class="comment">//找过的置1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是康托展开，我上面的解释是以编程，即应用的角度出发去理解的。读者也可以思考一下他的数学内涵(可从排列的角度出发)</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>我们的基本思路就是BFS+Cantor解决这玩意，当然还有双向bfs和A*等算法，读者可以尝试，下面给出我的AC代码(优化的可以)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">state</span>&#123;</span><br><span class="line"><span class="type">int</span> num[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> re;</span><br><span class="line">&#125;;<span class="comment">//定义状态结构体</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">char</span>&gt; ans;<span class="comment">//用vector存答案</span></span><br><span class="line">state q[<span class="number">666666</span>];<span class="comment">//模拟队列</span></span><br><span class="line"><span class="type">int</span> hh,tt = <span class="number">-1</span>;<span class="comment">//头,尾指针</span></span><br><span class="line"><span class="type">int</span> beg[<span class="number">9</span>];<span class="comment">//开始数组</span></span><br><span class="line"><span class="type">int</span> aim[<span class="number">9</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>&#125;;<span class="comment">//目标数组</span></span><br><span class="line"><span class="type">int</span> org[<span class="number">9</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;<span class="comment">//原数组，Cantor展开用</span></span><br><span class="line"><span class="type">int</span> factory[<span class="number">11</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;<span class="comment">//阶乘打表</span></span><br><span class="line"><span class="type">bool</span> vis[<span class="number">362881</span>];<span class="comment">//找过的数放进来</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> * basket)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; x;++i)</span><br><span class="line"><span class="keyword">if</span>(basket[i])</span><br><span class="line">++cnt;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cantor</span><span class="params">(<span class="type">int</span> * a)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> basket[<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)&#123;</span><br><span class="line">x += (a[i] - <span class="built_in">g</span>(a[i],basket)) * factory[<span class="number">8</span>-i];</span><br><span class="line">basket[a[i]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vis[x])<span class="comment">//判断是否找过</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//找过就false</span></span><br><span class="line">vis[x] = <span class="literal">true</span>;<span class="comment">//没找过就放进来</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//没找过就true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">state <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">state begin;</span><br><span class="line"><span class="built_in">memcpy</span>(begin.num,beg,<span class="keyword">sizeof</span> beg);<span class="comment">//把begin数组给初始状态</span></span><br><span class="line">begin.re = <span class="number">-1</span>;</span><br><span class="line">q[++tt] = begin;</span><br><span class="line"><span class="keyword">while</span>(tt &gt;= hh)&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)</span><br><span class="line"><span class="keyword">if</span>(q[hh].num[i] == aim[i])</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">9</span>) <span class="keyword">return</span> q[hh];</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line"><span class="keyword">for</span>(z = <span class="number">0</span>;z &lt; <span class="number">9</span>;++z)</span><br><span class="line"><span class="keyword">if</span>(q[hh].num[z] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>((z+<span class="number">1</span>)%<span class="number">3</span>)&#123;</span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cantor</span>(tmp.num)) q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z % <span class="number">3</span>)&#123;</span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cantor</span>(tmp.num)) q[++tt] = tmp;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z &gt; <span class="number">2</span>)&#123;</span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z<span class="number">-3</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cantor</span>(tmp.num)) q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(z &lt; <span class="number">6</span>)&#123;</span><br><span class="line">state tmp;</span><br><span class="line">tmp.ch = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">tmp.re = hh;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp.num,q[hh].num,<span class="built_in">sizeof</span> (q[hh].num));</span><br><span class="line"><span class="built_in">swap</span>(tmp.num[z],tmp.num[z+<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cantor</span>(tmp.num)) q[++tt] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">++hh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> chtmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)&#123;</span><br><span class="line">cin &gt;&gt; chtmp;</span><br><span class="line"><span class="keyword">if</span>(chtmp == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">beg[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">beg[i] = chtmp - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;<span class="comment">//读入begin数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cantor</span>(beg);<span class="comment">//初始状态放进vis</span></span><br><span class="line">state answer = <span class="built_in">bfs</span>();</span><br><span class="line"><span class="keyword">if</span>(answer.re == <span class="number">-1</span>)&#123;<span class="comment">//如果没找到目标，输出unsolvable</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unsolvable\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(answer.re != <span class="number">-1</span>)&#123;</span><br><span class="line">ans.<span class="built_in">push_back</span>(answer.ch);</span><br><span class="line">answer = q[answer.re];<span class="comment">//一层一层向上找，把ch存入答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = ans.<span class="built_in">end</span>()<span class="number">-1</span>;i &gt;= ans.<span class="built_in">begin</span>();--i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*i);<span class="comment">//逆序输出答案</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thats all</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八数码问题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
